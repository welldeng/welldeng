<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Mr.Onion"><meta name="copyright" content="Mr.Onion"><meta name="generator" content="Hexo 5.0.0"><meta name="theme" content="hexo-theme-yun"><title>深入学习正则表达式 | Mr.Onion</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="none" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.19/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_stqaphw3j4.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/avatar.svg"><link rel="mask-icon" href="/avatar.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"root":"/","title":"前端小站","version":"0.9.7","anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","say":{"api":"https://v1.hitokoto.cn","hitokoto":true},"fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><meta name="description" content="正则里括号的用法1. 分组分组：正则表达式里括号的表达式为另外一组匹配规则 捕获括号：被匹配的子字符串可以在结果数组的元素 [1]-[n] 中找到，或在被定义的 RegExp 对象的属性 $1-$9 中找到。 代码举例： 12345let reg &#x3D; &#x2F;\d+(\D+)&#x2F;reg.exec(&#39;123456abcd&#39;)&#x2F;&#x2F; [&amp;quot">
<meta property="og:type" content="article">
<meta property="og:title" content="深入学习正则表达式">
<meta property="og:url" content="https://welldeng.github.io/2019/04/13/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/index.html">
<meta property="og:site_name" content="Mr.Onion">
<meta property="og:description" content="正则里括号的用法1. 分组分组：正则表达式里括号的表达式为另外一组匹配规则 捕获括号：被匹配的子字符串可以在结果数组的元素 [1]-[n] 中找到，或在被定义的 RegExp 对象的属性 $1-$9 中找到。 代码举例： 12345let reg &#x3D; &#x2F;\d+(\D+)&#x2F;reg.exec(&#39;123456abcd&#39;)&#x2F;&#x2F; [&amp;quot">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-04-13T14:44:34.000Z">
<meta property="article:modified_time" content="2020-09-02T00:55:42.884Z">
<meta property="article:author" content="Mr.Onion">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary"></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="文章目录"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="站点概览"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Mr.Onion"><img width="96" loading="lazy" src="/avatar.jpg" alt="Mr.Onion"></a><div class="site-author-name"><a href="/about/">Mr.Onion</a></div><a class="site-name" href="/about/site.html">Mr.Onion</a><sub class="site-subtitle">Keep Moving</sub><div class="site-desciption">一个记录成长的前端博客</div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="首页"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="归档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">19</span></a></div><div class="site-state-item"><a href="/categories/" title="分类"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">5</span></a></div><div class="site-state-item"><a href="/tags/" title="标签"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">5</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/welldeng" title="GitHub" target="_blank" style="color:#6e5494"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://music.163.com/#/user/home?id=265412419" title="网易云音乐" target="_blank" style="color:#C20C0C"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-netease-cloud-music-line"></use></svg></a></div></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E9%87%8C%E6%8B%AC%E5%8F%B7%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">正则里括号的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%86%E7%BB%84"><span class="toc-number">1.1.</span> <span class="toc-text">1. 分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">2.反向引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%9B%B6%E5%AE%BD%E6%96%AD%E8%A8%80"><span class="toc-number">1.3.</span> <span class="toc-text">3.零宽断言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%9D%9E%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">贪婪模式与非贪婪模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">贪婪模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E8%B4%AA%E5%A9%AA%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">非贪婪模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E5%AE%BD%E6%96%AD%E8%A8%80"><span class="toc-number">3.</span> <span class="toc-text">零宽断言</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://welldeng.github.io/2019/04/13/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Mr.Onion"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="Mr.Onion"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">深入学习正则表达式</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="创建时间：2019-04-13 22:44:34" itemprop="dateCreated datePublished" datetime="2019-04-13T22:44:34+08:00">2019-04-13</time></div><div class="post-classify"><span class="post-category"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category" href="/categories/JavaScript/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">JavaScript</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag" href="/tags/JavaScript/" style="--text-color:#F4DF4F"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">JavaScript</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><h2 id="正则里括号的用法"><a href="#正则里括号的用法" class="headerlink" title="正则里括号的用法"></a>正则里括号的用法</h2><h3 id="1-分组"><a href="#1-分组" class="headerlink" title="1. 分组"></a>1. 分组</h3><p>分组：正则表达式里括号的表达式为另外一组匹配规则</p>
<p>捕获括号：被匹配的子字符串可以在结果数组的元素 [1]-[n] 中找到，或在被定义的 RegExp 对象的属性 $1-$9 中找到。</p>
<p>代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;\d+(\D+)&#x2F;</span><br><span class="line">reg.exec(&#39;123456abcd&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;123456abcd&quot;, &quot;abcd&quot;, index: 0, input: &quot;123456abcd&quot;, groups: undefined]</span><br><span class="line">console.log(RegExp.$1)</span><br><span class="line">&#x2F;&#x2F; &quot;abcd&quot;</span><br></pre></td></tr></table></figure>

<p>在这个正则表达式里我们括号期望的是一组非数字的匹配项，并且执行匹配后可在执行结果的[1]或者RegExp.$1得到匹配值。</p>
<p>正则表达式括号的分组在实际开发中对于我们解决问题有非常大的用处，例如String.replace()这个方法</p>
<p>代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;123abc&#39;</span><br><span class="line">let reg &#x3D; &#x2F;(\d+)(\D+)&#x2F;</span><br><span class="line">let newStr &#x3D; str.replace(reg, &#39;$2$1&#39;)</span><br><span class="line">console.log(newStr) &#x2F;&#x2F; abc123</span><br><span class="line">str.replace(reg, function(word, $1, $2)&#123;</span><br><span class="line">    console.log(word,$1,$2)</span><br><span class="line">    &#x2F;&#x2F; word代表字符串在正则匹配到的值, $1代表第一个括号的匹配项, $2代表第二个括号的匹配项</span><br><span class="line">    &#x2F;&#x2F; 123abc, 123, abc</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用正则表达式应用于字符串处理，在上面的例子里我们很容易得就把数字和字母的匹配项互换位置。</p>
<p>在另外一种情况下如果不想要捕获这个匹配项，但是又需要加括号匹配条件，我们可以使用非捕获括号</p>
<p>非捕获括号：匹配项不能够从结果数组的元素 [1]-[n] 或已被定义的 RegExp 对象的属性 $1-$9 再次访问到。</p>
<p>代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;\d+(?:\D+)&#x2F;</span><br><span class="line">reg.exec(&#39;123456abcd&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;123456abcd&quot;, index: 0, input: &quot;123456abcd&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>在例子里执行匹配后括号里的匹配项不会再出现结果里。</p>
<h3 id="2-反向引用"><a href="#2-反向引用" class="headerlink" title="2.反向引用"></a>2.反向引用</h3><p>反向引用：一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。</p>
<p>代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg &#x3D; &#x2F;(\d+)\D+\1&#x2F;</span><br><span class="line">reg.exec(&#39;123abc123&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;123abc123&quot;, &quot;123&quot;, index: 0, input: &quot;123abc123&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>在正则表达式里\1代表的是\d+，当我们在表达式里有需要重复的时候可以用这种写法。</p>
<h3 id="3-零宽断言"><a href="#3-零宽断言" class="headerlink" title="3.零宽断言"></a>3.零宽断言</h3><p>零宽断言：指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p>
<ol>
<li>(?=pattern) 正向先行断言：代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern。</li>
<li>(?!pattern) 负向先行断言：代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配pattern。</li>
<li>(?&lt;=pattern) 正向后行断言：代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配pattern。</li>
<li>(?&lt;!pattern) 负向后行断言：代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配pattern。</li>
</ol>
<p>正则表达式的括号有时候用来表达断言，具体的细节我们在下面问内容详细说。</p>
<h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><p>贪婪模式与非贪婪模式也是正则里面比较常见的问题了，平时也会经常应用于开发中解决问题。理解贪婪模式和非贪婪模式对我们理解正则引擎执行匹配非常有帮助。</p>
<h3 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h3><p>贪婪模式会匹配尽可能多的字符，贪婪模式用于匹配优先量词修饰的子表达式，匹配优先量词包括：“{m，n}”、“{m，}”、“?”、“*”和“+”</p>
<p>代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;\d*&#x2F;</span><br><span class="line">reg.exec(&#39;1234567890&#39;)</span><br><span class="line">[&quot;1234567890&quot;, index: 0, input: &quot;1234567890&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>*号代表匹配任意次数，用大括号代表即{0,}，在贪婪模式下尽可能多的匹配，在例子中因为整个字符串完全匹配，所以匹配值为 1234567890。</p>
<h3 id="非贪婪模式"><a href="#非贪婪模式" class="headerlink" title="非贪婪模式"></a>非贪婪模式</h3><p>非贪婪模式会匹配尽可能少的字符，在匹配量词后面加上问号就可触发非贪婪模式：“{m，n}?”、“{m，}?”、“??”、“*?”和“+?”</p>
<p>代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;\d*?&#x2F;</span><br><span class="line">reg.exec(&#39;1234567890&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;&quot;, index: 0, input: &quot;1234567890&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>*号代表匹配任意次数，用大括号代表即{0,}，因为*号可代表匹配0次，在非贪婪模式下尽可能少的匹配，所以在这个例子里匹配项为空，即不匹配任何字符串。</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>正则表达式的断言功能非常强大，学习正则的断言应用，对于解决我们开发中的问题提供了新的思路。</p>
<p>在理解断言的执行过程可能会稍微有点绕，但是作为一个开发肯定要有一颗爱折腾的心，哈哈。</p>
<p>下面将只使用正向先行断言来说明断言的执行，其他的三个模式也是大同小异。</p>
<p>先看一个简单例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;abc(?&#x3D;123)&#x2F;</span><br><span class="line">reg.exec(&#39;abc123&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;abc&quot;, index: 0, input: &quot;abc123&quot;, groups: undefined]</span><br><span class="line"></span><br><span class="line">let reg2 &#x3D; &#x2F;abc(?&#x3D;1234)&#x2F;</span><br><span class="line">reg2.exec(&#39;abc123&#39;)</span><br><span class="line">&#x2F;&#x2F; null</span><br><span class="line"></span><br><span class="line">let reg3 &#x3D; &#x2F;abc(?&#x3D;12)&#x2F;</span><br><span class="line">reg3.exec(&#39;abc123&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;abc&quot;, index: 0, input: &quot;abc123&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>先按照正则的字面意思理解，/abc(?=123)/期望的匹配为即匹配abc，<strong>且abc后面的字符串能够满足括号的匹配规则</strong>，注意的是括号里面可以为其他<strong>正则表达式</strong>，并不是说abc后面只能包含123，而是后面可以满足括号的匹配则为断言成功。</p>
<p>在reg2的匹配过程中，因为abc后面的字符串不满足括号的匹配规则，所以断言失败，执行匹配也失败了。</p>
<p>在这几个例子里还没有体现出我们概念里说的意思，重温一下正向先行断言的概念</p>
<p>(?=pattern) 正向先行断言：代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern</p>
<p>概念里说的意思断言是在字符串中寻找符合断言的一个位置</p>
<p>举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;(?&#x3D;abc).*&#x2F;</span><br><span class="line">reg.exec(&#39;123abc123&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;abc123&quot;, index: 3, input: &quot;123abc123&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>先分析正则表达式，在满足abc匹配条件的位置后面匹配任意字符。在这个例子里，存在abc满足断言的匹配规则，但是为什么匹配到的是abc123？</p>
<p>在这里就回到我们的标题，零宽断言，零宽的意思就是执行断言是不会消耗我们正则表达式在匹配过程中的字符串，并且，断言是在帮我们确定符合断言匹配规则的位置。所以，(?=abc)会帮我们确定一个断言成功的位置，即3和a之间的位置，然后在这个断言成功的位置开始执行匹配（.*）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;(?&#x3D;abc)\d+&#x2F;</span><br><span class="line">reg.exec(&#39;123abc123&#39;)</span><br><span class="line">&#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，虽然abc的断言成功，但是断言只是帮我们确定一个位置，然后再执行\d+匹配规则，因为断言是不会消耗字符串，所以实际上以abc123去和\d+匹配，最后匹配结果为null。</p>
<p>基于此我们可以使用断言帮我们从一开始检索整个字符串是否满足某些规则，有助于提升匹配效率。</p>
<p>如下例子，我们可以使用断言从一开始判断整个字符串是否全部由数字组成，如果断言失败，则不执行匹配，这对于我们应用于表单校验非常有助于提升效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg &#x3D; &#x2F;(?&#x3D;^\d+$)\d+&#x2F;</span><br><span class="line">reg.exec(&#39;123456&#39;)  &#x2F;&#x2F; 123456</span><br><span class="line">reg.exec(&#39;123456a&#39;) &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<p>另外没有介绍到的三种模式也是大同小异，在这里也就不重复赘述。但是两种后行断言可能会存在兼容性问题，后行断言应该是ES2018新增的规范。</p>
<p>零宽断言的重点是要理解“<strong>零宽</strong>”以及“<strong>位置</strong>”这两个点。</p>
<p>最后总结一下：正则表达式是一门非常实用的工具语言，基本上只要学习了就能够对于我们实际开发中产生帮助，平时某些开发工具中也可以使用正则表达式去检索某些文档，对于提升效率真的是帮助非常大。</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>Mr.Onion</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="https://welldeng.github.io/2019/04/13/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="深入学习正则表达式">https://welldeng.github.io/2019/04/13/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本博客所有文章除特别声明外，均默认采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> 许可协议。</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2019/04/20/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" rel="prev" title="前端跨域的解决方案"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">前端跨域的解决方案</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2019/04/06/%E7%90%86%E8%A7%A3JS%E7%9A%84eventloop/" rel="next" title="理解JS的eventloop"><span class="post-nav-text">理解JS的eventloop</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2020 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Mr.Onion</span></div><div class="powered"><span>由 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 驱动 v5.0.0</span><span class="footer-separator">|</span><span>主题 - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v0.9.7</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>