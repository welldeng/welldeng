<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Mr.Onion</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一个记录成长的前端博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Mr.Onion">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mr.Onion">
<meta property="og:description" content="一个记录成长的前端博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Onion">
<meta property="article:tag" content="HTML、JavaScript、Css、Web、前端">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Mr.Onion" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mr.Onion</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JS数据类型判断" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/15/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/" class="article-date">
  <time datetime="2020-08-15T14:52:01.000Z" itemprop="datePublished">2020-08-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/15/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/">JS数据类型判断</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前端数据类型判断"><a href="#前端数据类型判断" class="headerlink" title="前端数据类型判断"></a><strong>前端数据类型判断</strong></h1><blockquote>
<p>前端数据类型判断在开发过程中经常会遇到，那么我们又该怎么判断各种不同的数据类型呢？通过阅读文章，给你一套完整的判断方法以及对前端JS里数据类型的基本了解。</p>
</blockquote>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>javascript中的基础数据类型共有8种</p>
<ol>
<li>string</li>
<li>number（特殊值NaN）</li>
<li>boolean</li>
<li>undefined</li>
<li>object（正则表达式、array、map、set、function属于对象类型）</li>
<li>null</li>
<li>symbol</li>
<li>bigInt</li>
</ol>
<h2 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h2><h3 id="typeof方法判断"><a href="#typeof方法判断" class="headerlink" title="typeof方法判断"></a>typeof方法判断</h3><p>下面代码列出我们开发中经常用到的数据类型进行比较，代码如下👇</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// &#x27;number&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// &#x27;boolean&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> /\d/ <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2020&#x27;</span>) <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Map</span>() <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Set</span>() <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// &#x27;symbol&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> BigInt(<span class="number">1</span>) <span class="comment">// &#x27;bigInt&#x27;</span></span><br></pre></td></tr></table></figure>

<p>把结果整理成表格如下方表格展示，通过表格中的结果对比来看，使用<code>typeof</code>方法判有以下2个缺陷：</p>
<ol>
<li>无法区分<strong>数字</strong>和<strong>NaN</strong></li>
<li>无法区分<strong>null</strong>、**{}<strong>、</strong>[]<strong>、</strong>/\d/<strong>、</strong>new Map()<strong>、</strong>new Set()**这些对象类型</li>
</ol>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1、NaN</td>
<td>number</td>
</tr>
<tr>
<td>‘1’</td>
<td>string</td>
</tr>
<tr>
<td>true</td>
<td>boolean</td>
</tr>
<tr>
<td>null、{}、[]、/\d/、new Map()、new Set()</td>
<td>object</td>
</tr>
<tr>
<td>function() {}</td>
<td>function</td>
</tr>
<tr>
<td>Symbol()</td>
<td>symbol</td>
</tr>
<tr>
<td>BigInt(1)</td>
<td>bigInt</td>
</tr>
</tbody></table>
<h3 id="toString方法判断"><a href="#toString方法判断" class="headerlink" title="toString方法判断 "></a>toString方法判断 </h3><p><code>toString</code>方法是判断数据类型最精确的，下面代码列出我们开发中经常用到的数据类型进行比较，代码如下👇</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(val)</span><br><span class="line">&#125;</span><br><span class="line">func(<span class="number">1</span>) <span class="comment">// &#x27;[object Number]&#x27;</span></span><br><span class="line">func(<span class="literal">NaN</span>) <span class="comment">// &#x27;[object Number]&#x27;</span></span><br><span class="line">func(<span class="string">&#x27;1&#x27;</span>) <span class="comment">// &#x27;[object String]&#x27;</span></span><br><span class="line">func(<span class="literal">true</span>) <span class="comment">// &#x27;[object Boolean]&#x27;</span></span><br><span class="line">func(<span class="literal">undefined</span>) <span class="comment">// &#x27;[object Undefined]&#x27;</span></span><br><span class="line">func(<span class="literal">null</span>) <span class="comment">// &#x27;[object Null]&#x27;</span></span><br><span class="line">func([]) <span class="comment">// &#x27;[object Array]&#x27;</span></span><br><span class="line">func(&#123;&#125;) <span class="comment">// &#x27;[object Object]&#x27;</span></span><br><span class="line">func(<span class="regexp">/\d/</span>) <span class="comment">// &#x27;[object RegExp]&#x27;</span></span><br><span class="line">func(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">&#x27;2020&#x27;</span>)) <span class="comment">// &#x27;[object Date]&#x27;</span></span><br><span class="line">func(<span class="keyword">new</span> <span class="built_in">Map</span>()) <span class="comment">// &#x27;[object Map]&#x27;</span></span><br><span class="line">func(<span class="keyword">new</span> <span class="built_in">Set</span>()) <span class="comment">// &#x27;[object Set]&#x27;</span></span><br><span class="line">func(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// &#x27;[object Function]&#x27;</span></span><br><span class="line">func(<span class="built_in">Symbol</span>()) <span class="comment">// &#x27;[object Symbol]&#x27;</span></span><br><span class="line">func(BigInt(<span class="number">1</span>)) <span class="comment">// &#x27;[object BigInt]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>把结果整理成表格如下方表格展示，通过表格中的结果对比来看，使用<code>toString</code>方法判断数据类型已经接近完美，但是特殊的值<code>NaN</code>还是无法区分，不过这个数据在开发过程中还是比较少出现的，判断方法在下文补充。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>1、NaN</td>
<td>[object Number]</td>
</tr>
<tr>
<td>‘1’</td>
<td>[object String]</td>
</tr>
<tr>
<td>true</td>
<td>[object Boolean]</td>
</tr>
<tr>
<td>undefined</td>
<td>[object Undefined]</td>
</tr>
<tr>
<td>null</td>
<td>[object Null]</td>
</tr>
<tr>
<td>[]</td>
<td>[object Array]</td>
</tr>
<tr>
<td>{}</td>
<td>[object Object]</td>
</tr>
<tr>
<td>/\d/</td>
<td>[object RegExp]</td>
</tr>
<tr>
<td>new Date(‘2020’)</td>
<td>[object Date]</td>
</tr>
<tr>
<td>new Map()</td>
<td>[object Map]</td>
</tr>
<tr>
<td>new Set()</td>
<td>[object Set]</td>
</tr>
<tr>
<td>function() {}</td>
<td>[object Function]</td>
</tr>
<tr>
<td>Symbol()</td>
<td>[object Symbol]</td>
</tr>
<tr>
<td>BigInt(1)</td>
<td>[object BigInt]</td>
</tr>
</tbody></table>
<h2 id="特殊点"><a href="#特殊点" class="headerlink" title="特殊点"></a>特殊点</h2><ul>
<li><p>通过前文中整理可得，<code>NaN</code>这个特殊值无论是用<code>typeof</code>还是<code>toString</code>都无法区分，判断这个值最好使用<code>Number.isNaN</code>，该方法返还一个布尔值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>还有一类数据是使用构造函数生成，这种数据从使用<code>typeof</code>和<code>toString</code>得到的结果来看，<code>typeof</code>方法得到的结果会更准确。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> func = <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> newNum = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">let</span> newBool = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> newStr <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> newNum <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> newBool <span class="comment">// &#x27;object&#x27;</span></span><br><span class="line"></span><br><span class="line">func(newStr) <span class="comment">// &#x27;[object String]&#x27;</span></span><br><span class="line">func(newNum) <span class="comment">// &#x27;[object Number]&#x27;</span></span><br><span class="line">func(newBool) <span class="comment">// &#x27;[object Boolean]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>从上面代码可以得到，在这个时候虽然使用<code>toString</code>方法得到的数据构造方法是正确的，但是真正的变量返回结果却是对象类型的，对于这种使用构造函数得到的返回值，结合<code>typeof</code>和<code>toString</code>一起判断是最精确的。</p>
</li>
<li><p>对于判断数组类型，我们还可以使用新的语法<code>Array.isArray</code>判断，返回的结果是一个布尔值。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/15/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/" data-id="ckedpbrub00061zm16qfr1jel" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-CSS容易忽略的一些知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/08/10/CSS%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
  <time datetime="2019-08-10T09:27:40.000Z" itemprop="datePublished">2019-08-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/CSS/">CSS</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/08/10/CSS%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/">CSS容易忽略的一些知识点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="inline元素、inline-block元素、block元素的区别"><a href="#inline元素、inline-block元素、block元素的区别" class="headerlink" title="inline元素、inline-block元素、block元素的区别"></a><code>inline</code>元素、<code>inline-block</code>元素、<code>block</code>元素的区别</h2><ol>
<li><code>inline</code>元素根据宽度横向排列，<code>block</code>元素默认独占一行；</li>
<li><code>inline</code>元素无法设置上下外边距(<code>margin</code>)、<code>width</code>、<code>height</code>，<code>block</code>元素可以设置四个方向的外边距和元素的<code>width</code>、<code>height</code>；</li>
<li><code>inline-block</code>元素则融合了<code>inline</code>元素和<code>block</code>元素，可以像<code>inline</code>元素横向排列以及像<code>block</code>元素设置四个方向的外边距以及<code>width</code>、<code>height</code>；</li>
</ol>
<p>效果图如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/10/16c7a14e82ef9a8e?w=740&h=758&f=png&s=57903"></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;display: block;width: 100px;height: 100px;background-color: red;margin: 10px;padding: 10px;border: 1px solid grey;&quot;&gt;block&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;display: inline-block;width: 100px;height: 100px;background-color: blue;margin: 10px;padding: 10px;border: 1px solid grey;&quot;&gt;inline-block&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;display: inline;width: 100px;height: 100px;background-color: yellow;margin: 10px;padding: 10px;border: 1px solid grey;&quot;&gt;inline&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>我们给<code>inline</code>元素设置四个方向外边距，只有左右的外边距才显示出了效果。</p>
<h2 id="flex-grow容易忽略的坑"><a href="#flex-grow容易忽略的坑" class="headerlink" title="flex-grow容易忽略的坑"></a><code>flex-grow</code>容易忽略的坑</h2><p>我们先看看<code>flex-grow</code>的定义：</p>
<p><code>flex-grow</code>属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p>
<p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<p>根据定义我们可以得知，当在<code>flex</code>容器内给容器内的项目设置不同的<code>flex-grow</code>，可以根据比例设置项目的空间；</p>
<p>先看第一个例子：</p>
<p><code>flex</code>容器宽度为<code>780px</code>，容器内有三个项目，第一个项目固定宽度<code>480px</code>，剩下的两个项目根据比例分配。</p>
<p>效果图如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/10/16c7a23650a45341?w=1570&h=522&f=jpeg&s=48236"></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;display: flex;color: grey;width: 780px;&quot;&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;height:100px;flex-basis: 480px;background-color: red;&quot;&gt;width480px&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;height:100px;flex-grow: 2;background-color: blue;&quot;&gt;flex-grow: 2&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;height:100px;flex-grow: 1;background-color: yellow;&quot;&gt;flex-grow: 1&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>从效果图得知，除了固定宽度的项目，另外两个项目的宽度并未按照我们所想的那样分配。</p>
<p>重新去看定义，分配“_剩余空间_”似乎并不是我们理解的那样，具体这个“_剩余空间_”是如何计算我并未具体去研究，在这里先说说如何解决这个问题。</p>
<ol>
<li>当剩余两个项目内不存在内容的时候，分配的空间就是正确的；<br>效果图如下：<br><img src="https://user-gold-cdn.xitu.io/2019/8/10/16c7a2b825c7ad9b?w=1602&h=422&f=jpeg&s=30203"><br>代码如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;display: flex;color: grey;width: 780px;&quot;&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;height:100px;flex-basis: 480px;background-color: red;&quot;&gt;width480px&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;height:100px;flex-grow: 2;background-color: blue;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;height:100px;flex-grow: 1;background-color: yellow;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>当我们把除了固定宽度外的项目的内容去掉，分配的空间比例就是正确的，但是这种解决方法肯定不是我们想要的。</p>
<ol start="2">
<li>给剩余两个项目设置<code>flex-basic: 0;</code></li>
</ol>
<p>效果图如下：<br><img src="https://user-gold-cdn.xitu.io/2019/8/10/16c7a2e66c7eb215?w=1604&h=566&f=jpeg&s=51175"><br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;display: flex;color: grey;width: 780px;&quot;&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;height:100px;flex-basis: 480px;background-color: red;&quot;&gt;width480px&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;height:100px;flex-grow: 2;background-color: blue;flex-basis: 0;&quot;&gt;flex-grow: 2&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;height:100px;flex-grow: 1;background-color: yellow;flex-basis: 0;&quot;&gt;flex-grow: 1&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>在这里当我们给除了固定宽度外的项目加上<code>flex-basic: 0</code>后，分配的空间就是我们所期望的那样了。</p>
<p>如果我们需要使用<code>flex-grow</code>来分配<code>flex</code>容器内的项目，一定要注意设置<code>flex-basic</code>。因为这里的“_剩余空间_”和<code>flex-basic</code>相关。</p>
<p>下面我们看看<code>flex-basic</code>的定义：</p>
<p><code>flex-basic</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</p>
<p>当我们一个<code>flex</code>容器内的项目同时存在<code>flex-basic</code>和<code>flex-grow</code>，这个项目的宽度为<code>flex-basic</code>的值加上<code>flex-grow</code>所分配到的空间。</p>
<p>还是以上面的代码举例，假如我们给两个项目的<code>flex-basic</code>设置值为<code>30px</code>和<code>60px</code></p>
<p>则剩余两个容器的宽度分别为：</p>
<p><code>width1 = ((780 - 480 - 30 - 60) * 2 / 3) + 30 = 170</code></p>
<p><code>width2 = ((780 - 480 - 30 - 60) * 1 / 3) + 60 = 130</code></p>
<p>效果图如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/10/16c7a5a01b1f48fe?w=1610&h=494&f=jpeg&s=54951"><br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&quot;display: flex;color: grey;width: 780px;&quot;&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;height:100px;flex-basis: 480px;background-color: red;&quot;&gt;width480px&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;height:100px;flex-grow: 2;background-color: blue;flex-basis: 30px;&quot;&gt;flex-grow: 2&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;div style&#x3D;&quot;height:100px;flex-grow: 1;background-color: yellow;flex-basis: 60px;&quot;&gt;flex-grow: 1&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="多个class样式的时候如何取值？"><a href="#多个class样式的时候如何取值？" class="headerlink" title="多个class样式的时候如何取值？"></a>多个<code>class</code>样式的时候如何取值？</h2><p>当某个<code>div</code>元素上<code>class</code>的值为<code>a b c</code>的时候，最后的样式是如何计算的？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;a b c&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>这个问题我们讨论的前提是同样的样式属性；</p>
<ol>
<li>不考虑权重的情况下，<code>a b c</code>最终决定元素的样式为加载的顺序，哪个<code>class</code>最后加载则显示为哪个<code>class</code>的效果，和书写顺序无关。</li>
</ol>
<ul>
<li>当<code>a b c</code>都在同一个文件的情况下，哪个定义在最后，则以最后的为准；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.c &#123;</span><br><span class="line">    background-color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.b &#123;</span><br><span class="line">    background-color: yellow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.a &#123;</span><br><span class="line">    background-color: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当<code>a b c</code>在不同的文件的情况下，哪个文件最后加载，则以最后的为准；</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;cssC.css&quot;&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;cssB.css&quot;&gt;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;cssA.css&quot;&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>如果某个<code>class</code>中设置了<code>!important</code>，则直接以<code>!important</code>的为准。</p>
</li>
<li><p>其他时候则按照选择器的权重来计算样式。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/08/10/CSS%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/" data-id="ckedpbru200011zm10cb5cgg6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习vuex源码" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/15/%E5%AD%A6%E4%B9%A0vuex%E6%BA%90%E7%A0%81/" class="article-date">
  <time datetime="2019-07-15T09:43:10.000Z" itemprop="datePublished">2019-07-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/15/%E5%AD%A6%E4%B9%A0vuex%E6%BA%90%E7%A0%81/">学习vuex源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>这一篇主要是讲解<code>vuex</code>的大概实现，以及一些细节的说明。</p>
</blockquote>
<h3 id="vuex是如何实现的？"><a href="#vuex是如何实现的？" class="headerlink" title="vuex是如何实现的？"></a><code>vuex</code>是如何实现的？</h3><p>先从<code>install</code>方法看，安装插件的方法实现比较简单，调用<code>applyMixin</code>，最后执行的是这段逻辑<code>Vue.mixin(&#123; beforeCreate: vuexInit &#125;)</code>，实际上是在每个组件创建时混入<code>store</code>实例。所以我们可以在每个组件上获取到<code>store</code>实例上的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">if (version &gt;&#x3D; 2) &#123;</span><br><span class="line">Vue.mixin(&#123; beforeCreate: vuexInit &#125;)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">&#x2F;&#x2F; override init and inject vuex init procedure</span><br><span class="line">&#x2F;&#x2F; for 1.x backwards compatibility.</span><br><span class="line">const _init &#x3D; Vue.prototype._init</span><br><span class="line">Vue.prototype._init &#x3D; function (options &#x3D; &#123;&#125;) &#123;</span><br><span class="line">  options.init &#x3D; options.init</span><br><span class="line">    ? [vuexInit].concat(options.init)</span><br><span class="line">    : vuexInit</span><br><span class="line">  _init.call(this, options)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function vuexInit () &#123;</span><br><span class="line">const options &#x3D; this.$options</span><br><span class="line">&#x2F;&#x2F; store injection</span><br><span class="line">if (options.store) &#123;</span><br><span class="line">  this.$store &#x3D; typeof options.store &#x3D;&#x3D;&#x3D; &#39;function&#39;</span><br><span class="line">    ? options.store()</span><br><span class="line">    : options.store</span><br><span class="line">&#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class="line">  this.$store &#x3D; options.parent.$store</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function install (_Vue) &#123;</span><br><span class="line">  if (Vue &amp;&amp; _Vue &#x3D;&#x3D;&#x3D; Vue) &#123;</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">      console.error(</span><br><span class="line">        &#39;[vuex] already installed. Vue.use(Vuex) should be called only once.&#39;</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  Vue &#x3D; _Vue</span><br><span class="line">  applyMixin(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看看<code>store</code>这个类的代码：</p>
<p>在这个类上暴露了<code>commit</code>和<code>dispatch</code>方法，并且绑定了调用上下文为<code>store</code>的实例。<code>dispatch</code>支持异步更新数据是因为它内部的实现就是使用了<code>promise</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; bind commit and dispatch to self</span><br><span class="line">const store &#x3D; this</span><br><span class="line">const &#123; dispatch, commit &#125; &#x3D; this</span><br><span class="line">this.dispatch &#x3D; function boundDispatch (type, payload) &#123;</span><br><span class="line">  return dispatch.call(store, type, payload)</span><br><span class="line">&#125;</span><br><span class="line">this.commit &#x3D; function boundCommit (type, payload, options) &#123;</span><br><span class="line">  return commit.call(store, type, payload, options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面两个方法是<code>vuex</code>的实现主要逻辑，<code>installModule</code>的具体逻辑不细说，从注释上我们可以知道，这是一个初始化整个<code>vuex</code>配置生成对象的方法。根据配置进行递归执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; init root module.</span><br><span class="line">&#x2F;&#x2F; this also recursively registers all sub-modules</span><br><span class="line">&#x2F;&#x2F; and collects all module getters inside this._wrappedGetters</span><br><span class="line">installModule(this, state, [], this._modules.root)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; initialize the store vm, which is responsible for the reactivity</span><br><span class="line">&#x2F;&#x2F; (also registers _wrappedGetters as computed properties)</span><br><span class="line">resetStoreVM(this, state)</span><br></pre></td></tr></table></figure>

<p><code>resetStoreVM</code>方法比较重要，下面是该方法的详细代码：</p>
<ol>
<li><code>vuex</code>中的<code>getter</code>实际上是使用<code>vue</code>计算属性实现的，<code>Object.defineProperty</code>里定义了<code>getter</code>的<code>get</code>方法。</li>
<li><code>store._vm</code>实际就是<code>vuex</code>把<code>installModule</code>生成的对象改造成响应式的数据，通过一个新的<code>vue</code>实例。</li>
<li>最后则是当我们重置<code>vuex</code>的响应数据，需要销毁旧的实例，回收内存。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">function resetStoreVM (store, state, hot) &#123;</span><br><span class="line">  const oldVm &#x3D; store._vm</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; bind store public getters</span><br><span class="line">  store.getters &#x3D; &#123;&#125;</span><br><span class="line">  const wrappedGetters &#x3D; store._wrappedGetters</span><br><span class="line">  const computed &#x3D; &#123;&#125;</span><br><span class="line">  forEachValue(wrappedGetters, (fn, key) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; use computed to leverage its lazy-caching mechanism</span><br><span class="line">    &#x2F;&#x2F; direct inline function use will lead to closure preserving oldVm.</span><br><span class="line">    &#x2F;&#x2F; using partial to return function with only arguments preserved in closure enviroment.</span><br><span class="line">    computed[key] &#x3D; partial(fn, store)</span><br><span class="line">    Object.defineProperty(store.getters, key, &#123;</span><br><span class="line">      get: () &#x3D;&gt; store._vm[key],</span><br><span class="line">      enumerable: true &#x2F;&#x2F; for local getters</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; use a Vue instance to store the state tree</span><br><span class="line">  &#x2F;&#x2F; suppress warnings just in case the user has added</span><br><span class="line">  &#x2F;&#x2F; some funky global mixins</span><br><span class="line">  const silent &#x3D; Vue.config.silent</span><br><span class="line">  Vue.config.silent &#x3D; true</span><br><span class="line">  store._vm &#x3D; new Vue(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      $$state: state</span><br><span class="line">    &#125;,</span><br><span class="line">    computed</span><br><span class="line">  &#125;)</span><br><span class="line">  Vue.config.silent &#x3D; silent</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; enable strict mode for new vm</span><br><span class="line">  if (store.strict) &#123;</span><br><span class="line">    enableStrictMode(store)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (oldVm) &#123;</span><br><span class="line">    if (hot) &#123;</span><br><span class="line">      &#x2F;&#x2F; dispatch changes in all subscribed watchers</span><br><span class="line">      &#x2F;&#x2F; to force getter re-evaluation for hot reloading.</span><br><span class="line">      store._withCommit(() &#x3D;&gt; &#123;</span><br><span class="line">        oldVm._data.$$state &#x3D; null</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    Vue.nextTick(() &#x3D;&gt; oldVm.$destroy())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改vuex的数据是如何响应到视图？"><a href="#修改vuex的数据是如何响应到视图？" class="headerlink" title="修改vuex的数据是如何响应到视图？"></a>修改<code>vuex</code>的数据是如何响应到视图？</h3><ol>
<li><code>vuex</code>的<code>state</code>和<code>getter</code>实际上就是对应的<code>store._vm</code>（<code>vue</code>实例）中<code>data</code>和<code>computed</code>，因此<code>getter</code>所依赖的<code>state</code>最后是通过<code>watcher</code>管理的。</li>
<li>当我们在组件中使用<code>vuex</code>，<code>vuex</code>生成的实例对象在<code>vue</code>实例化过程中被改造成响应式的数据，当我们有多个页面组件使用了<code>vuex</code>的数据，其实也是通过<code>watcher</code>管理，因此当我们使用<code>commit</code>或<code>dispatch</code>修改数据，最后触发了<code>setter</code>去通知所有订阅者（<code>watcher</code>）更新。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>vuex</code>的设计其实并不复杂，简单的来讲，就是一个对象，通过内部的方法管理内部的属性和读取内部的属性。</p>
<p>而实现的过程，则是通过一系列方法把我们的配置生成一个<code>root</code>对象，然后利用<code>vue</code>实现内部数据的响应与依赖管理。而这里比较核心的部分则是当数据发生变化时，如何响应到对应的视图部分以及<code>getter</code>的依赖管理，这些逻辑的实现最后都是通过<code>watcher</code>。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/15/%E5%AD%A6%E4%B9%A0vuex%E6%BA%90%E7%A0%81/" data-id="ckedpbrum000s1zm11ex81lrg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习vue源码—nextTick" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/07/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94nextTick/" class="article-date">
  <time datetime="2019-07-07T14:40:14.000Z" itemprop="datePublished">2019-07-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/07/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94nextTick/">学习vue源码—nextTick</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>这一篇主要讲讲<code>nextTick</code>源码，看看该方法的实现，以及为何能在这个方法里保证拿到<code>DOM</code>节点。</p>
</blockquote>
<p><code>nextTick</code>方法在<code>./src/core/util/next-tick.js</code>，下面为部分源码展示：</p>
<ol>
<li><code>nextTick</code>方法接受两个入参，分别是回调方法<code>cb</code>和上下文<code>ctx</code>;</li>
<li>函数部分逻辑，首先不管是否存在<code>cb</code>参数都会往队列推入一个函数，后续任务队列根据<code>cb</code>参数判断是否调用<code>cb</code>或者是否执行<code>_resolve(ctx)</code>修改<code>promise</code>状态；</li>
<li>判断<code>pending</code>状态是否执行任务</li>
<li>最后则是该函数的返回值为一个<code>promise</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export function nextTick (cb?: Function, ctx?: Object) &#123;</span><br><span class="line">  let _resolve</span><br><span class="line">  callbacks.push(() &#x3D;&gt; &#123;</span><br><span class="line">    if (cb) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; catch (e) &#123;</span><br><span class="line">        handleError(e, ctx, &#39;nextTick&#39;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  if (!pending) &#123;</span><br><span class="line">    pending &#x3D; true</span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; $flow-disable-line</span><br><span class="line">  if (!cb &amp;&amp; typeof Promise !&#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class="line">    return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">      _resolve &#x3D; resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先来说说调用<code>nextTick</code>的返回值，因为返回值是一个<code>promise</code>，所以我们可以使用<code>then</code>的写法或者<code>async/await</code>的写法，加上使用<code>cb</code>的写法，存在三种写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this.$nextTick(function() &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">this.$nextTick().then((ctx)&#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; do something</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"></span><br><span class="line">await this.$nextTick()</span><br><span class="line">&#x2F;&#x2F; do something</span><br></pre></td></tr></table></figure>

<p>接下来则是<code>nextTick</code>里比较重要的方法<code>timerFunc</code>的实现：</p>
<ol>
<li>优先使用原生<code>Promise</code>；</li>
<li>后使用<code>MutationObserver</code>；</li>
<li>再后使用<code>setImmediate</code>;</li>
<li>最后使用<code>setTimeout</code>;</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">if (typeof Promise !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; isNative(Promise)) &#123;</span><br><span class="line">  const p &#x3D; Promise.resolve()</span><br><span class="line">  timerFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    &#x2F;&#x2F; In problematic UIWebViews, Promise.then doesn&#39;t completely break, but</span><br><span class="line">    &#x2F;&#x2F; it can get stuck in a weird state where callbacks are pushed into the</span><br><span class="line">    &#x2F;&#x2F; microtask queue but the queue isn&#39;t being flushed, until the browser</span><br><span class="line">    &#x2F;&#x2F; needs to do some other work, e.g. handle a timer. Therefore we can</span><br><span class="line">    &#x2F;&#x2F; &quot;force&quot; the microtask queue to be flushed by adding an empty timer.</span><br><span class="line">    if (isIOS) setTimeout(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask &#x3D; true</span><br><span class="line">&#125; else if (!isIE &amp;&amp; typeof MutationObserver !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  &#x2F;&#x2F; PhantomJS and iOS 7.x</span><br><span class="line">  MutationObserver.toString() &#x3D;&#x3D;&#x3D; &#39;[object MutationObserverConstructor]&#39;</span><br><span class="line">)) &#123;</span><br><span class="line">  &#x2F;&#x2F; Use MutationObserver where native Promise is not available,</span><br><span class="line">  &#x2F;&#x2F; e.g. PhantomJS, iOS7, Android 4.4</span><br><span class="line">  &#x2F;&#x2F; (#6466 MutationObserver is unreliable in IE11)</span><br><span class="line">  let counter &#x3D; 1</span><br><span class="line">  const observer &#x3D; new MutationObserver(flushCallbacks)</span><br><span class="line">  const textNode &#x3D; document.createTextNode(String(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    characterData: true</span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    counter &#x3D; (counter + 1) % 2</span><br><span class="line">    textNode.data &#x3D; String(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask &#x3D; true</span><br><span class="line">&#125; else if (typeof setImmediate !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  &#x2F;&#x2F; Fallback to setImmediate.</span><br><span class="line">  &#x2F;&#x2F; Techinically it leverages the (macro) task queue,</span><br><span class="line">  &#x2F;&#x2F; but it is still a better choice than setTimeout.</span><br><span class="line">  timerFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; Fallback to setTimeout.</span><br><span class="line">  timerFunc &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(flushCallbacks, 0)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码中<code>isUsingMicroTask</code>中可以看到只有<code>Promise</code>、<code>MutationObserver</code>属于微任务，另外两个则属于宏任务；看到该方法的实现我们就可以知道为什么在<code>nextTick</code>方法中能保证拿到<code>DOM</code>。</p>
<p>两种场景的解释：</p>
<ol>
<li>在<code>vue</code>第一次初始化的时候，我们在<code>beforeCreated</code>和<code>created</code>生命周期里想要使用<code>DOM</code>则必须使用<code>nextTick</code>，这是因为初始化的过程属于宏任务，整个函数调用栈未清空，<code>nextTick</code>的回调属于微任务，所以<code>nextTick</code>的回调必须在整个初始化结束后才会执行。</li>
<li>在修改<code>data</code>数据后，又如何保证获取修改后的数据<code>DOM</code>？修改<code>data</code>数据实际上是触发组件实例的<code>watcher</code>执行<code>update</code>更新，而在<code>update</code>里面又执行了<code>queueWatcher</code>，下面👇则是<code>queueWatcher</code>方法的代码，在代码里面我们可以看到最后实际上也是调用<code>nextTick(flushSchedulerQueue)</code>。因此，想获取<code>data</code>修改后的<code>DOM</code>，调用<code>nextTick</code>能保证这种任务执行的顺序。</li>
</ol>
<p>了解<code>watcher</code>可以看这篇<a target="_blank" rel="noopener" href="https://juejin.im/post/5d181bafe51d457753138219">https://juejin.im/post/5d181bafe51d457753138219</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">export function queueWatcher (watcher: Watcher) &#123;</span><br><span class="line">  const id &#x3D; watcher.id</span><br><span class="line">  if (has[id] &#x3D;&#x3D; null) &#123;</span><br><span class="line">    has[id] &#x3D; true</span><br><span class="line">    if (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; if already flushing, splice the watcher based on its id</span><br><span class="line">      &#x2F;&#x2F; if already past its id, it will be run next immediately.</span><br><span class="line">      let i &#x3D; queue.length - 1</span><br><span class="line">      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + 1, 0, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; queue the flush</span><br><span class="line">    if (!waiting) &#123;</span><br><span class="line">      waiting &#x3D; true</span><br><span class="line"></span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实<code>queueWatcher</code>方法里面的逻辑还告诉了我们另外一个框架知识点：</p>
<p><strong>为什么我们同时修改多个data属性，不会多次更新视图？</strong></p>
<p>在<code>update</code>方法里，因为最后实际上调用<code>nextTick</code>执行微任务去更新视图，了解过<code>event loop</code>机制的应该知道，必须等待当前宏任务的调用栈清空才去执行微任务，这也就是为什么当我们同时修改多个<code>data</code>属性时候，该判断<code>if (has[id] == null) </code>防止重复添加更新任务，并且利用了<code>event loop</code>机制在合适的时机去更新视图。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/07/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94nextTick/" data-id="ckedpbruq000z1zm10bms81q9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习vue源码—mvvm" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/30/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94mvvm/" class="article-date">
  <time datetime="2019-06-30T14:43:12.000Z" itemprop="datePublished">2019-06-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/30/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94mvvm/">学习vue源码—mvvm</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>这一篇主要是讲解一下vue里mvvm的原理，以及如何理解vue实现mvvm。</p>
</blockquote>
<p>稍微有去了解过vue是如何双向绑定的我们都很容易知道vue是通过<code>Object.defineProperty</code>劫持<code>data</code>属性的<code>setter</code>和<code>getter</code>，但是这仅仅只是实现的一部分，在这个实现里我们还要理解<code>dep</code>（订阅中心）和<code>watcher</code>（订阅者）的概念。</p>
<h3 id="dep—订阅中心"><a href="#dep—订阅中心" class="headerlink" title="dep—订阅中心"></a><code>dep</code>—订阅中心</h3><p><code>dep</code>代码在<code>./src/core/observer/dep.js</code>文件里，下面简单讲解一下：</p>
<ol>
<li><code>dep</code>的定义参考了观察者设计模式，每一个<code>dep</code>有自己的唯一标识<code>id</code>和订阅者列表<code>subs</code>。</li>
<li><code>addSub</code>和<code>removeSub</code>用来管理订阅者列表<code>subs</code>。</li>
<li><code>depend</code>用来收集<code>watcher</code>（订阅者）。</li>
<li><code>notify</code>用来通知<code>watcher</code>（订阅者）执行更新。</li>
<li><code>Dep.target</code>刚开始看是比较难理解的一个概念，<code>Dep.target</code>其实是调用当前<code>dep</code>对应属性的<code>watcher</code>。举个例子：假如<code>data</code>有个属性<code>name</code>，那么当<code>data.name</code>的<code>getter</code>被触发时，我们需要知道是谁在调用这个<code>data.name</code>的<code>getter</code>，这就是<code>Dep.target</code>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">export default class Dep &#123;</span><br><span class="line">  static target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: Array&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.id &#x3D; uid++</span><br><span class="line">    this.subs &#x3D; []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    &#x2F;&#x2F; stabilize the subscriber list first</span><br><span class="line">    const subs &#x3D; this.subs.slice()</span><br><span class="line">    if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; !config.async) &#123;</span><br><span class="line">      &#x2F;&#x2F; subs aren&#39;t sorted in scheduler if not running async</span><br><span class="line">      &#x2F;&#x2F; we need to sort them now to make sure they fire in correct</span><br><span class="line">      &#x2F;&#x2F; order</span><br><span class="line">      subs.sort((a, b) &#x3D;&gt; a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i &#x3D; 0, l &#x3D; subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; The current target watcher being evaluated.</span><br><span class="line">&#x2F;&#x2F; This is globally unique because only one watcher</span><br><span class="line">&#x2F;&#x2F; can be evaluated at a time.</span><br><span class="line">Dep.target &#x3D; null</span><br><span class="line">const targetStack &#x3D; []</span><br><span class="line"></span><br><span class="line">export function pushTarget (target: ?Watcher) &#123;</span><br><span class="line">  targetStack.push(target)</span><br><span class="line">  Dep.target &#x3D; target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function popTarget () &#123;</span><br><span class="line">  targetStack.pop()</span><br><span class="line">  Dep.target &#x3D; targetStack[targetStack.length - 1]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="watcher—订阅者"><a href="#watcher—订阅者" class="headerlink" title="watcher—订阅者"></a><code>watcher</code>—订阅者</h3><p><code>watcher</code>代码在<code>./src/core/observer/watcher.js</code>文件里，关于<code>watcher</code>的选项配置就不细说了，在这里我们只需要重点关注其中的<code>get</code><br>、<code>update</code>、<code>run</code>、<code>evaluate</code>这几个方法。</p>
<p>这几个方法的作用稍后解释，现在我们要先理解怎样才会产生一个<code>watcher</code>。在vue里面，有三种类型的<code>watcher</code>：</p>
<ol>
<li>每一个组件的实例都是一个<code>watcher</code></li>
<li>在组件的<code>watch</code>选项中声明的<code>watcher</code></li>
<li>计算属性所使用的依赖值会给对应的依赖值添加一个<code>watcher</code></li>
</ol>
<p>讲完<code>watcher</code>的来源后我们再来看这几个方法的讲解：</p>
<ol>
<li>先从<code>update</code>讲起，当某个响应属性发生变化时触发<code>setter</code>后，执行<code>dep.notify</code>通知每个<code>watcher</code>执行<code>update</code>，代码比较简单，三个逻辑分支，判断<code>this.lazy</code>，这是应用于<font color=red>计算属性</font>时会触发的逻辑分支，<code>this.sync<br></code>则用于判断同步执行<code>watcher</code>的回调，否则推入<code>queueWatcher</code>后续执行。</li>
<li><code>run</code>和<code>evaluate</code>都是会调用<code>get</code>方法，只是<code>run</code>方法是用于组件实例的<code>watcher</code>和<code>watch</code>选项中声明的<code>watcher</code>，<code>watch</code>选项中声明的<code>watcher</code>的<code>this.user</code>为<code>true</code>，在<code>run</code>方法中的<code>this.cb.call(this.vm, value, oldValue)</code>这段代码则是我们<code>watch</code>选项中触发的回调。至于<code>evaluate</code>方法则更加简单了，调用<code>get</code>方法然后设置<code>this.dirty</code>为<code>false</code>则是为了后续其他地方使用这个计算属性的时候不需要重新计算，这也是<font color=red>计算属性缓存</font>的一部分逻辑。</li>
<li>接下来讲讲<code>get</code>方法，<code>pushTarget(this)</code>这段则是设置<code>Dep.target</code>为当前<code>watcher</code>实例，其实就是告诉<code>dep</code>是谁在获取属性。<code>value = this.getter.call(vm, vm)</code>则是获取当前值，在这里三种类型的<code>watcher</code>的<code>getter</code>是不一样的。</li>
<li>最后提一下，计算属性的值一般是在组件实例的<code>watcher</code>执行<code>getter</code>的过程中执行计算的。</li>
</ol>
<table>
<thead>
<tr>
<th>watcher类型</th>
<th>getter</th>
</tr>
</thead>
<tbody><tr>
<td>组件实例</td>
<td>render函数</td>
</tr>
<tr>
<td>watch</td>
<td>执行parsePath方法生成的函数</td>
</tr>
<tr>
<td>计算属性</td>
<td>执行createComputedGetter方法生成的函数</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line">export default class Watcher &#123;</span><br><span class="line">  vm: Component;</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: Function;</span><br><span class="line">  id: number;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: Array&lt;Dep&gt;;</span><br><span class="line">  newDeps: Array&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?Function;</span><br><span class="line">  getter: Function;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  constructor (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.vm &#x3D; vm</span><br><span class="line">    if (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher &#x3D; this</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(this)</span><br><span class="line">    &#x2F;&#x2F; options</span><br><span class="line">    if (options) &#123;</span><br><span class="line">      this.deep &#x3D; !!options.deep</span><br><span class="line">      this.user &#x3D; !!options.user</span><br><span class="line">      this.lazy &#x3D; !!options.lazy</span><br><span class="line">      this.sync &#x3D; !!options.sync</span><br><span class="line">      this.before &#x3D; options.before</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.deep &#x3D; this.user &#x3D; this.lazy &#x3D; this.sync &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">    this.cb &#x3D; cb</span><br><span class="line">    this.id &#x3D; ++uid &#x2F;&#x2F; uid for batching</span><br><span class="line">    this.active &#x3D; true</span><br><span class="line">    this.dirty &#x3D; this.lazy &#x2F;&#x2F; for lazy watchers</span><br><span class="line">    this.deps &#x3D; []</span><br><span class="line">    this.newDeps &#x3D; []</span><br><span class="line">    this.depIds &#x3D; new Set()</span><br><span class="line">    this.newDepIds &#x3D; new Set()</span><br><span class="line">    this.expression &#x3D; process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;</span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : &#39;&#39;</span><br><span class="line">    &#x2F;&#x2F; parse expression for getter</span><br><span class="line">    if (typeof expOrFn &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">      this.getter &#x3D; expOrFn</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.getter &#x3D; parsePath(expOrFn)</span><br><span class="line">      if (!this.getter) &#123;</span><br><span class="line">        this.getter &#x3D; noop</span><br><span class="line">        process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39; &amp;&amp; warn(</span><br><span class="line">          &#96;Failed watching path: &quot;$&#123;expOrFn&#125;&quot; &#96; +</span><br><span class="line">          &#39;Watcher only accepts simple dot-delimited paths. &#39; +</span><br><span class="line">          &#39;For full control, use a function instead.&#39;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.value &#x3D; this.lazy</span><br><span class="line">      ? undefined</span><br><span class="line">      : this.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Evaluate the getter, and re-collect dependencies.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  get () &#123;</span><br><span class="line">    pushTarget(this)</span><br><span class="line">    let value</span><br><span class="line">    const vm &#x3D; this.vm</span><br><span class="line">    try &#123;</span><br><span class="line">      value &#x3D; this.getter.call(vm, vm)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      if (this.user) &#123;</span><br><span class="line">        handleError(e, vm, &#96;getter for watcher &quot;$&#123;this.expression&#125;&quot;&#96;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      &#x2F;&#x2F; &quot;touch&quot; every property so they are all tracked as</span><br><span class="line">      &#x2F;&#x2F; dependencies for deep watching</span><br><span class="line">      if (this.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      this.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Add a dependency to this directive.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    const id &#x3D; dep.id</span><br><span class="line">    if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">      this.newDepIds.add(id)</span><br><span class="line">      this.newDeps.push(dep)</span><br><span class="line">      if (!this.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Clean up for dependency collection.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    let i &#x3D; this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      const dep &#x3D; this.deps[i]</span><br><span class="line">      if (!this.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let tmp &#x3D; this.depIds</span><br><span class="line">    this.depIds &#x3D; this.newDepIds</span><br><span class="line">    this.newDepIds &#x3D; tmp</span><br><span class="line">    this.newDepIds.clear()</span><br><span class="line">    tmp &#x3D; this.deps</span><br><span class="line">    this.deps &#x3D; this.newDeps</span><br><span class="line">    this.newDeps &#x3D; tmp</span><br><span class="line">    this.newDeps.length &#x3D; 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Subscriber interface.</span><br><span class="line">   * Will be called when a dependency changes.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  update () &#123;</span><br><span class="line">    &#x2F;* istanbul ignore else *&#x2F;</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty &#x3D; true</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">      this.run()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      queueWatcher(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Scheduler job interface.</span><br><span class="line">   * Will be called by the scheduler.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  run () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      const value &#x3D; this.get()</span><br><span class="line">      if (</span><br><span class="line">        value !&#x3D;&#x3D; this.value ||</span><br><span class="line">        &#x2F;&#x2F; Deep watchers and watchers on Object&#x2F;Arrays should fire even</span><br><span class="line">        &#x2F;&#x2F; when the value is the same, because the value may</span><br><span class="line">        &#x2F;&#x2F; have mutated.</span><br><span class="line">        isObject(value) ||</span><br><span class="line">        this.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F; set new value</span><br><span class="line">        const oldValue &#x3D; this.value</span><br><span class="line">        this.value &#x3D; value</span><br><span class="line">        if (this.user) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            this.cb.call(this.vm, value, oldValue)</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            handleError(e, this.vm, &#96;callback for watcher &quot;$&#123;this.expression&#125;&quot;&#96;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.cb.call(this.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Evaluate the value of the watcher.</span><br><span class="line">   * This only gets called for lazy watchers.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    this.value &#x3D; this.get()</span><br><span class="line">    this.dirty &#x3D; false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Depend on all deps collected by this watcher.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  depend () &#123;</span><br><span class="line">    let i &#x3D; this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      this.deps[i].depend()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * Remove self from all dependencies&#39; subscriber list.</span><br><span class="line">   *&#x2F;</span><br><span class="line">  teardown () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      &#x2F;&#x2F; remove self from vm&#39;s watcher list</span><br><span class="line">      &#x2F;&#x2F; this is a somewhat expensive operation so we skip it</span><br><span class="line">      &#x2F;&#x2F; if the vm is being destroyed.</span><br><span class="line">      if (!this.vm._isBeingDestroyed) &#123;</span><br><span class="line">        remove(this.vm._watchers, this)</span><br><span class="line">      &#125;</span><br><span class="line">      let i &#x3D; this.deps.length</span><br><span class="line">      while (i--) &#123;</span><br><span class="line">        this.deps[i].removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">      this.active &#x3D; false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>其实学习vue的mvvm，重点在于<code>dep</code>和<code>watcher</code>的理解，要明白这两个类的实例在双向绑定的过程中扮演的是一个什么样角色，单纯从代码上可能不太容易理解这样设计的意图，但是如果能有一个比较具象化的东西来对应，相信对你的理解会有非常大的帮助。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/30/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94mvvm/" data-id="ckedpbrup000w1zm1bccs8iv3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习vue源码—vue-diff" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/23/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94vue-diff/" class="article-date">
  <time datetime="2019-06-23T14:40:48.000Z" itemprop="datePublished">2019-06-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/23/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94vue-diff/">学习vue源码—vue-diff</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>本文主要记录vue-diff的原理以及说明一个响应式数据更新的流程是怎么样的一个过程。</p>
</blockquote>
<h2 id="1-数据改变到页面渲染的过程是怎么样的？"><a href="#1-数据改变到页面渲染的过程是怎么样的？" class="headerlink" title="1. 数据改变到页面渲染的过程是怎么样的？"></a>1. 数据改变到页面渲染的过程是怎么样的？</h2><p>首先看下面的图片👇，这是执行click函数改变一个数据之后发生的函数调用栈，从图上的说明可以比较清楚个了解这个响应式过程的大概流程。下面简单讲解一下：</p>
<ol>
<li>改变数据，触发这个被劫持过的数据的<code>setter</code>方法</li>
<li>执行这个数据的订阅中心（<code>dep</code>）的<code>notify</code>方法</li>
<li><code>update</code>方法里执行<code>queueWatcher</code>方法把<code>watcher</code>推入队列</li>
<li>执行<code>nextTick</code>方法开始更新视图</li>
<li><code>run</code>方法里设置<code>dep.target</code>为当前订阅对象</li>
<li>调用<code>get</code>方法调用当前<code>watcher</code>的<code>getter</code>执行更新方法</li>
<li><code>updateComponent</code>方法里调用了<code>render</code>方法开始执行渲染页面</li>
<li><code>patch</code>、<code>patchVnode</code>、<code>updateChildren</code>方法都是比较VNode更新渲染的函数，不过重点的diff过程在<code>updateChildren</code>方法里。<br><img src="https://user-gold-cdn.xitu.io/2019/6/23/16b83a2e38faea15?w=1016&h=1066&f=png&s=181273"></li>
</ol>
<h2 id="2-vue-diff的具体实现"><a href="#2-vue-diff的具体实现" class="headerlink" title="2. vue-diff的具体实现"></a>2. vue-diff的具体实现</h2><p><code>patchVnode</code>、<code>updateChildren</code>方法在vue源码项目的<code>src/core/vdom/patch.js</code>文件中。</p>
<p>先介绍<code>patchVnode</code>方法，这是执行真正更新dom的方法，大概的执行逻辑如下</p>
<ol>
<li>判断vnode和oldVnode是否相等</li>
<li>判断是否能重用vnode</li>
<li>判断是否执行回调</li>
<li>判断是否有children需要diff更新</li>
<li>判断执行更新类型—新增dom、移除dom、更新textDom</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">function patchVnode (</span><br><span class="line">  oldVnode,</span><br><span class="line">  vnode,</span><br><span class="line">  insertedVnodeQueue,</span><br><span class="line">  ownerArray,</span><br><span class="line">  index,</span><br><span class="line">  removeOnly</span><br><span class="line">) &#123;</span><br><span class="line">  if (oldVnode &#x3D;&#x3D;&#x3D; vnode) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    &#x2F;&#x2F; clone reused vnode</span><br><span class="line">    vnode &#x3D; ownerArray[index] &#x3D; cloneVNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const elm &#x3D; vnode.elm &#x3D; oldVnode.elm</span><br><span class="line"></span><br><span class="line">  if (isTrue(oldVnode.isAsyncPlaceholder)) &#123;</span><br><span class="line">    if (isDef(vnode.asyncFactory.resolved)) &#123;</span><br><span class="line">      hydrate(oldVnode.elm, vnode, insertedVnodeQueue)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      vnode.isAsyncPlaceholder &#x3D; true</span><br><span class="line">    &#125;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; reuse element for static trees.</span><br><span class="line">  &#x2F;&#x2F; note we only do this if the vnode is cloned -</span><br><span class="line">  &#x2F;&#x2F; if the new node is not cloned it means the render functions have been</span><br><span class="line">  &#x2F;&#x2F; reset by the hot-reload-api and we need to do a proper re-render.</span><br><span class="line">  if (isTrue(vnode.isStatic) &amp;&amp;</span><br><span class="line">    isTrue(oldVnode.isStatic) &amp;&amp;</span><br><span class="line">    vnode.key &#x3D;&#x3D;&#x3D; oldVnode.key &amp;&amp;</span><br><span class="line">    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))</span><br><span class="line">  ) &#123;</span><br><span class="line">    vnode.componentInstance &#x3D; oldVnode.componentInstance</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let i</span><br><span class="line">  const data &#x3D; vnode.data</span><br><span class="line">  if (isDef(data) &amp;&amp; isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.prepatch)) &#123;</span><br><span class="line">    i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  const oldCh &#x3D; oldVnode.children</span><br><span class="line">  const ch &#x3D; vnode.children</span><br><span class="line">  if (isDef(data) &amp;&amp; isPatchable(vnode)) &#123;</span><br><span class="line">    for (i &#x3D; 0; i &lt; cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)</span><br><span class="line">    if (isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.update)) i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  if (isUndef(vnode.text)) &#123;</span><br><span class="line">    if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123;</span><br><span class="line">      if (oldCh !&#x3D;&#x3D; ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; else if (isDef(ch)) &#123;</span><br><span class="line">      if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">        checkDuplicateKeys(ch)</span><br><span class="line">      &#125;</span><br><span class="line">      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &#39;&#39;)</span><br><span class="line">      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</span><br><span class="line">    &#125; else if (isDef(oldCh)) &#123;</span><br><span class="line">      removeVnodes(oldCh, 0, oldCh.length - 1)</span><br><span class="line">    &#125; else if (isDef(oldVnode.text)) &#123;</span><br><span class="line">      nodeOps.setTextContent(elm, &#39;&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else if (oldVnode.text !&#x3D;&#x3D; vnode.text) &#123;</span><br><span class="line">    nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">  &#125;</span><br><span class="line">  if (isDef(data)) &#123;</span><br><span class="line">    if (isDef(i &#x3D; data.hook) &amp;&amp; isDef(i &#x3D; i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是我们经常说的vue-diff所在的方法<code>updateChildren</code>，先从参数说起，分别是父元素dom，旧的vnode-list，新的vnode-list，需要插入的vnode队列，是否仅移除。</p>
<p>重点的逻辑在<code>while</code>循环里：</p>
<p>如何理解这个diff逻辑，其实是分别有新旧两个vnode-list，两个list都设定第一位和最后一位作为两个游标，通过一系列判断对比，不断逼近，当两个list的两个游标相交则循环结束。</p>
<p>至于具体判断的逻辑就不赘述了，代码已经写得非常清楚了，在这里比较有意思的<code>sameVnode</code>的判断，在使用<code>v-for</code>生成的vnode-list不设置<code>key</code>的时候，所有的对比更新几乎都会从第三和第四个判断分支进行，即代码中的<code>sameVnode(oldStartVnode, newStartVnode)</code>和<code>sameVnode(oldEndVnode, newEndVnode)</code>判断，下面看看<code>sameVnode</code>的方法，当我们不设置key的时候，判断的逻辑会通过tag类型和vnode的数据某些属性进行比较，通常来说都是相同的，这就是官方文档说的<font color=red>原地复用</font>逻辑，直接更新当前节点的内容，不需要对当前的节点进行移动。这对于节点内容相对简单的来说默认会更高效，但是当节点内容相对复杂的时候我们就需要对节点内容进行复用而不是重新生成，这时候我们就需要设置<code>key</code>来复用节点。</p>
<p>最后的一段判断<code>oldStartIdx > oldEndIdx</code>和<code>newStartIdx > newEndIdx</code>则说明符合这两个条件的时候我们当前vnode-list是从无到有或从有到无的变化。</p>
<p>图示：官方文档的说明（👇）</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/23/16b84467afb18dfd?w=1458&h=632&f=png&s=186334"></p>
<p><code>sameVnode</code>方法定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function sameVnode (a, b) &#123;</span><br><span class="line">  return (</span><br><span class="line">    a.key &#x3D;&#x3D;&#x3D; b.key &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag &#x3D;&#x3D;&#x3D; b.tag &amp;&amp;</span><br><span class="line">        a.isComment &#x3D;&#x3D;&#x3D; b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) &#x3D;&#x3D;&#x3D; isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory &#x3D;&#x3D;&#x3D; b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updateChildren</code>方法定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">  let oldStartIdx &#x3D; 0</span><br><span class="line">  let newStartIdx &#x3D; 0</span><br><span class="line">  let oldEndIdx &#x3D; oldCh.length - 1</span><br><span class="line">  let oldStartVnode &#x3D; oldCh[0]</span><br><span class="line">  let oldEndVnode &#x3D; oldCh[oldEndIdx]</span><br><span class="line">  let newEndIdx &#x3D; newCh.length - 1</span><br><span class="line">  let newStartVnode &#x3D; newCh[0]</span><br><span class="line">  let newEndVnode &#x3D; newCh[newEndIdx]</span><br><span class="line">  let oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; removeOnly is a special flag used only by &lt;transition-group&gt;</span><br><span class="line">  &#x2F;&#x2F; to ensure removed elements stay in correct relative positions</span><br><span class="line">  &#x2F;&#x2F; during leaving transitions</span><br><span class="line">  const canMove &#x3D; !removeOnly</span><br><span class="line"></span><br><span class="line">  if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">    checkDuplicateKeys(newCh)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while (oldStartIdx &lt;&#x3D; oldEndIdx &amp;&amp; newStartIdx &lt;&#x3D; newEndIdx) &#123;</span><br><span class="line">    if (isUndef(oldStartVnode)) &#123;</span><br><span class="line">      oldStartVnode &#x3D; oldCh[++oldStartIdx] &#x2F;&#x2F; Vnode has been moved left</span><br><span class="line">    &#125; else if (isUndef(oldEndVnode)) &#123;</span><br><span class="line">      oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">    &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      oldStartVnode &#x3D; oldCh[++oldStartIdx]</span><br><span class="line">      newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">    &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">      newEndVnode &#x3D; newCh[--newEndIdx]</span><br><span class="line">    &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; &#x2F;&#x2F; Vnode moved right</span><br><span class="line">      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">      oldStartVnode &#x3D; oldCh[++oldStartIdx]</span><br><span class="line">      newEndVnode &#x3D; newCh[--newEndIdx]</span><br><span class="line">    &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; &#x2F;&#x2F; Vnode moved left</span><br><span class="line">      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">      canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">      oldEndVnode &#x3D; oldCh[--oldEndIdx]</span><br><span class="line">      newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (isUndef(oldKeyToIdx)) oldKeyToIdx &#x3D; createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      idxInOld &#x3D; isDef(newStartVnode.key)</span><br><span class="line">        ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">      if (isUndef(idxInOld)) &#123; &#x2F;&#x2F; New element</span><br><span class="line">        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        vnodeToMove &#x3D; oldCh[idxInOld]</span><br><span class="line">        if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)</span><br><span class="line">          oldCh[idxInOld] &#x3D; undefined</span><br><span class="line">          canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          &#x2F;&#x2F; same key but different element. treat as new element</span><br><span class="line">          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      newStartVnode &#x3D; newCh[++newStartIdx]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">    refElm &#x3D; isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class="line">    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">  &#125; else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">    removeVnodes(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实vue-diff的算法并不复杂，代码阅读起来也相对容易。在vue里从patch到视图的变化是实时的，即假如存在3个节点变化，vue并不是收集完所有的patch再一次性更新视图，而是在遍历diff的过程中patch直接更新视图。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/23/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94vue-diff/" data-id="ckedpbrur00131zm1cfntgzu1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习vue-router源码记录-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/16/%E5%AD%A6%E4%B9%A0vue-router%E6%BA%90%E7%A0%81%E8%AE%B0%E5%BD%95-2/" class="article-date">
  <time datetime="2019-06-16T14:42:32.000Z" itemprop="datePublished">2019-06-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/16/%E5%AD%A6%E4%B9%A0vue-router%E6%BA%90%E7%A0%81%E8%AE%B0%E5%BD%95-2/">学习vue-router源码记录-2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>继上一遍文章大概介绍了vue-router里面的概念，这一篇文章主要详细介绍路由跳转中发生了什么。</p>
</blockquote>
<p> 路由跳转执行的代码主要在<code>./base.js</code>文件里，详细看<code>transitionTo</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123;</span><br><span class="line">    const route &#x3D; this.router.match(location, this.current)</span><br><span class="line">    this.confirmTransition(route, () &#x3D;&gt; &#123;</span><br><span class="line">      this.updateRoute(route)</span><br><span class="line">      onComplete &amp;&amp; onComplete(route)</span><br><span class="line">      this.ensureURL()</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; fire ready cbs once</span><br><span class="line">      if (!this.ready) &#123;</span><br><span class="line">        this.ready &#x3D; true</span><br><span class="line">        this.readyCbs.forEach(cb &#x3D;&gt; &#123; cb(route) &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, err &#x3D;&gt; &#123;</span><br><span class="line">      if (onAbort) &#123;</span><br><span class="line">        onAbort(err)</span><br><span class="line">      &#125;</span><br><span class="line">      if (err &amp;&amp; !this.ready) &#123;</span><br><span class="line">        this.ready &#x3D; true</span><br><span class="line">        this.readyErrorCbs.forEach(cb &#x3D;&gt; &#123; cb(err) &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>transitionTo</code>代码非常简单，执行<code>this.route.match</code>，通过比较新的路由和就得路由拿到一个<code>route</code>对象，然后执行<code>confirmTransition</code>确认路由跳转。</p>
<p>下面看看这个<code>route</code>对象的定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">declare type Route &#x3D; &#123;</span><br><span class="line">  path: string;</span><br><span class="line">  name: ?string;</span><br><span class="line">  hash: string;</span><br><span class="line">  query: Dictionary&lt;string&gt;;</span><br><span class="line">  params: Dictionary&lt;string&gt;;</span><br><span class="line">  fullPath: string;</span><br><span class="line">  matched: Array&lt;RouteRecord&gt;;</span><br><span class="line">  redirectedFrom?: string;</span><br><span class="line">  meta?: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对照代码，我们主要看<code>matched</code>这个属性，在上一篇文章里面已经介绍过<code>RouteRecord</code>对象的定义。路由一开始会执行<code>createMatcher</code>生成一个路由映射表，因此<code>matched</code>里面存放就是我们<font color=red>将要跳转到的路由匹配上的路由配置对象</font>。</p>
<p>举一个简单的例子说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    path: &#39;&#x2F;parent&#39;,</span><br><span class="line">    component: Parent,</span><br><span class="line">    children: [</span><br><span class="line">    &#123; path: &#39;foo&#39;, component: Foo &#125;,</span><br><span class="line">    &#123; path: &#39;bar&#39;, component: Bar &#125;,</span><br><span class="line">    ],</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>假设我们配置了以下的路由，<code>createMatcher</code>会生成根据path建立的映射表</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pathMap &#x3D; &#123;</span><br><span class="line">    &#39;&#x2F;parent&#39;: RouteRecord,</span><br><span class="line">    &#39;&#x2F;parent&#x2F;foo&#39;: RouteRecord,</span><br><span class="line">    &#39;&#x2F;parent&#x2F;bar&#39;: RouteRecord,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>假如我们发生了一个从<code>/parent</code>路由跳转到<code>/parent/foo</code>路由，首先执行以下代码生成的<code>route</code>对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const route &#x3D; this.router.match(location, this.current)</span><br></pre></td></tr></table></figure>

<p>因此根据我们假设的配置，这里的<code>route</code>里的<code>matched</code>将会包含<code>/parent</code>和<code>/parent/foo</code>的<code>RouteRecord</code>。至于具体的<code>match</code>方法代码就不详细解释了。</p>
<p>继续讲路由的跳转，生成<code>route</code>对象后将会执行一个确认的方法<code>confirmTransition</code>。</p>
<p>由于这个方法代码比较长，我们拆开来说明，首先看这个方法的入参说明，接受三个参数，<code>route</code>对象在前面已经生成过了，另外两个是执行完成的回调方法和退出的回调方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">confirmTransition (route: Route, onComplete: Function, onAbort?: Function)</span><br></pre></td></tr></table></figure>

<p>在代码的一开始首先判断当前路由与跳转的路由是否是同一个路由，如果是则直接退出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const current &#x3D; this.current</span><br><span class="line">const abort &#x3D; err &#x3D;&gt; &#123;</span><br><span class="line">  if (isError(err)) &#123;</span><br><span class="line">    if (this.errorCbs.length) &#123;</span><br><span class="line">      this.errorCbs.forEach(cb &#x3D;&gt; &#123; cb(err) &#125;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      warn(false, &#39;uncaught error during route navigation:&#39;)</span><br><span class="line">      console.error(err)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  onAbort &amp;&amp; onAbort(err)</span><br><span class="line">&#125;</span><br><span class="line">if (</span><br><span class="line">  isSameRoute(route, current) &amp;&amp;</span><br><span class="line">  &#x2F;&#x2F; in the case the route map has been dynamically appended to</span><br><span class="line">  route.matched.length &#x3D;&#x3D;&#x3D; current.matched.length</span><br><span class="line">) &#123;</span><br><span class="line">  this.ensureURL()</span><br><span class="line">  return abort()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的<code>ensureURL</code>方法定义在<code>HTML5History</code>的原型链上，实际上执行的是保存路由变化历史记录，根据<code>push</code>是<code>true</code>或<code>false</code>来确定执行<code>pushState</code>还是<code>replaceState</code>。这一方法在执行完路由跳转后同样会执行一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTML5History.prototype.ensureURL &#x3D; function ensureURL (push) &#123;</span><br><span class="line">  if (getLocation(this.base) !&#x3D;&#x3D; this.current.fullPath) &#123;</span><br><span class="line">    var current &#x3D; cleanPath(this.base + this.current.fullPath);</span><br><span class="line">    push ? pushState(current) : replaceState(current);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>继续看后面的代码，首先通过<code>resolveQueue</code>对比<code>this.current</code>和<code>route</code>对象的<code>matched</code>提取三种变化的组件队列。根据命名我们直接可得知<code>updated</code>、<code>deactivated</code>、<code>activated</code>分别对应更新的组件、失效的组件、激活的组件。然后生成一个需要执行方法的队列<code>queue</code>，根据这个队列的生成定义，我们可以看出执行方法的顺序，至于通过<code>extractLeaveGuards</code>和<code>extractUpdateHooks</code>方法提取组件里的守卫函数就不细说了。</p>
<ol>
<li><p>在失活的组件里调用离开守卫。</p>
</li>
<li><p>调用全局的 beforeEach 守卫。</p>
</li>
<li><p>在重用的组件里调用 beforeRouteUpdate 守卫</p>
</li>
<li><p>在激活的路由配置里调用 beforeEnter。</p>
</li>
<li><p>解析异步路由组件。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">const &#123;</span><br><span class="line">  updated,</span><br><span class="line">  deactivated,</span><br><span class="line">  activated</span><br><span class="line">&#125; &#x3D; resolveQueue(this.current.matched, route.matched)</span><br><span class="line"></span><br><span class="line">const queue: Array&lt;?NavigationGuard&gt; &#x3D; [].concat(</span><br><span class="line">  &#x2F;&#x2F; in-component leave guards</span><br><span class="line">  extractLeaveGuards(deactivated),</span><br><span class="line">  &#x2F;&#x2F; global before hooks</span><br><span class="line">  this.router.beforeHooks,</span><br><span class="line">  &#x2F;&#x2F; in-component update hooks</span><br><span class="line">  extractUpdateHooks(updated),</span><br><span class="line">  &#x2F;&#x2F; in-config enter guards</span><br><span class="line">  activated.map(m &#x3D;&gt; m.beforeEnter),</span><br><span class="line">  &#x2F;&#x2F; async components</span><br><span class="line">  resolveAsyncComponents(activated)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>看看<code>resolveQueue</code>是如何提取变化的组件。比较<code>current</code>和<code>next</code>确定一个变化的位置<code>i</code>，<code>next</code>里的从<code>0</code>到<code>i</code>则是<code>updated</code>的部分，<code>i</code>之后的则是<code>activated</code>的部分，而<code>current</code>里<code>i</code>之后的则是<code>deactivated</code>的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function resolveQueue (</span><br><span class="line">  current: Array&lt;RouteRecord&gt;,</span><br><span class="line">  next: Array&lt;RouteRecord&gt;</span><br><span class="line">): &#123;</span><br><span class="line">  updated: Array&lt;RouteRecord&gt;,</span><br><span class="line">  activated: Array&lt;RouteRecord&gt;,</span><br><span class="line">  deactivated: Array&lt;RouteRecord&gt;</span><br><span class="line">&#125; &#123;</span><br><span class="line">  let i</span><br><span class="line">  const max &#x3D; Math.max(current.length, next.length)</span><br><span class="line">  for (i &#x3D; 0; i &lt; max; i++) &#123;</span><br><span class="line">    if (current[i] !&#x3D;&#x3D; next[i]) &#123;</span><br><span class="line">      break</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    updated: next.slice(0, i),</span><br><span class="line">    activated: next.slice(i),</span><br><span class="line">    deactivated: current.slice(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是生成迭代器方法<code>iterator</code>，执行<code>runQueue</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">this.pending &#x3D; route</span><br><span class="line">const iterator &#x3D; (hook: NavigationGuard, next) &#x3D;&gt; &#123;</span><br><span class="line">  if (this.pending !&#x3D;&#x3D; route) &#123;</span><br><span class="line">    return abort()</span><br><span class="line">  &#125;</span><br><span class="line">  try &#123;</span><br><span class="line">    hook(route, current, (to: any) &#x3D;&gt; &#123;</span><br><span class="line">      if (to &#x3D;&#x3D;&#x3D; false || isError(to)) &#123;</span><br><span class="line">        &#x2F;&#x2F; next(false) -&gt; abort navigation, ensure current URL</span><br><span class="line">        this.ensureURL(true)</span><br><span class="line">        abort(to)</span><br><span class="line">      &#125; else if (</span><br><span class="line">        typeof to &#x3D;&#x3D;&#x3D; &#39;string&#39; ||</span><br><span class="line">        (typeof to &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; (</span><br><span class="line">          typeof to.path &#x3D;&#x3D;&#x3D; &#39;string&#39; ||</span><br><span class="line">          typeof to.name &#x3D;&#x3D;&#x3D; &#39;string&#39;</span><br><span class="line">        ))</span><br><span class="line">      ) &#123;</span><br><span class="line">        &#x2F;&#x2F; next(&#39;&#x2F;&#39;) or next(&#123; path: &#39;&#x2F;&#39; &#125;) -&gt; redirect</span><br><span class="line">        abort()</span><br><span class="line">        if (typeof to &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; to.replace) &#123;</span><br><span class="line">          this.replace(to)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.push(to)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        &#x2F;&#x2F; confirm transition and pass on the value</span><br><span class="line">        next(to)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    abort(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">runQueue(queue, iterator, () &#x3D;&gt; &#123;</span><br><span class="line">  const postEnterCbs &#x3D; []</span><br><span class="line">  const isValid &#x3D; () &#x3D;&gt; this.current &#x3D;&#x3D;&#x3D; route</span><br><span class="line">  &#x2F;&#x2F; wait until async components are resolved before</span><br><span class="line">  &#x2F;&#x2F; extracting in-component enter guards</span><br><span class="line">  const enterGuards &#x3D; extractEnterGuards(activated, postEnterCbs, isValid)</span><br><span class="line">  const queue &#x3D; enterGuards.concat(this.router.resolveHooks)</span><br><span class="line">  runQueue(queue, iterator, () &#x3D;&gt; &#123;</span><br><span class="line">    if (this.pending !&#x3D;&#x3D; route) &#123;</span><br><span class="line">      return abort()</span><br><span class="line">    &#125;</span><br><span class="line">    this.pending &#x3D; null</span><br><span class="line">    onComplete(route)</span><br><span class="line">    if (this.router.app) &#123;</span><br><span class="line">      this.router.app.$nextTick(() &#x3D;&gt; &#123;</span><br><span class="line">        postEnterCbs.forEach(cb &#x3D;&gt; &#123; cb() &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>runQueue</code>方法的代码并不复杂，一个递归执行队列的方法，使用<code>iterator(fn参数)</code>执行<code>queue</code>，<code>iterator</code>里给<code>hook</code>传入的参数分别代表<code>to</code>、<code>from</code>、<code>next</code>，在队列执行完后执行传入的回调方法。这里执行过程代表了vue-router的守卫函数的执行函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">export function runQueue (queue: Array&lt;?NavigationGuard&gt;, fn: Function, cb: Function) &#123;</span><br><span class="line">  const step &#x3D; index &#x3D;&gt; &#123;</span><br><span class="line">    if (index &gt;&#x3D; queue.length) &#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      if (queue[index]) &#123;</span><br><span class="line">        fn(queue[index], () &#x3D;&gt; &#123;</span><br><span class="line">          step(index + 1)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        step(index + 1)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  step(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>综上所述，路由跳转的变化大概上已经解释完，当然这并不是完整的执行逻辑，只是路由跳转大概的过程差不多就是如此。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/16/%E5%AD%A6%E4%B9%A0vue-router%E6%BA%90%E7%A0%81%E8%AE%B0%E5%BD%95-2/" data-id="ckedpbrui000k1zm16u7na71n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习vue-router源码记录" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/07/%E5%AD%A6%E4%B9%A0vue-router%E6%BA%90%E7%A0%81%E8%AE%B0%E5%BD%95/" class="article-date">
  <time datetime="2019-06-07T14:42:32.000Z" itemprop="datePublished">2019-06-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>►<a class="article-category-link" href="/categories/JavaScript/Vue/">Vue</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/07/%E5%AD%A6%E4%B9%A0vue-router%E6%BA%90%E7%A0%81%E8%AE%B0%E5%BD%95/">学习vue-router源码记录-1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>因为本人开发中使用的是VUE技术栈，最近也是开始源码的学习，以此记录个人理解，若行文有误，请多多指教。</p>
</blockquote>
<h2 id="1-new-Router和install"><a href="#1-new-Router和install" class="headerlink" title="1.new Router和install"></a>1.new Router和install</h2><p>在vue中我们使用vue-router时需要先进行<code>new Router()</code>，执行<code>new Router()</code>后主要执行代码看看VueRouter class定义的<code>constructor</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">constructor (options: RouterOptions &#x3D; &#123;&#125;) &#123;</span><br><span class="line">    this.app &#x3D; null</span><br><span class="line">    this.apps &#x3D; []</span><br><span class="line">    this.options &#x3D; options</span><br><span class="line">    this.beforeHooks &#x3D; []</span><br><span class="line">    this.resolveHooks &#x3D; []</span><br><span class="line">    this.afterHooks &#x3D; []</span><br><span class="line">    this.matcher &#x3D; createMatcher(options.routes || [], this)</span><br><span class="line"></span><br><span class="line">    let mode &#x3D; options.mode || &#39;hash&#39;</span><br><span class="line">    this.fallback &#x3D; mode &#x3D;&#x3D;&#x3D; &#39;history&#39; &amp;&amp; !supportsPushState &amp;&amp; options.fallback !&#x3D;&#x3D; false</span><br><span class="line">    if (this.fallback) &#123;</span><br><span class="line">      mode &#x3D; &#39;hash&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!inBrowser) &#123;</span><br><span class="line">      mode &#x3D; &#39;abstract&#39;</span><br><span class="line">    &#125;</span><br><span class="line">    this.mode &#x3D; mode</span><br><span class="line"></span><br><span class="line">    switch (mode) &#123;</span><br><span class="line">      case &#39;history&#39;:</span><br><span class="line">        this.history &#x3D; new HTML5History(this, options.base)</span><br><span class="line">        break</span><br><span class="line">      case &#39;hash&#39;:</span><br><span class="line">        this.history &#x3D; new HashHistory(this, options.base, this.fallback)</span><br><span class="line">        break</span><br><span class="line">      case &#39;abstract&#39;:</span><br><span class="line">        this.history &#x3D; new AbstractHistory(this, options.base)</span><br><span class="line">        break</span><br><span class="line">      default:</span><br><span class="line">        if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;</span><br><span class="line">          assert(false, &#96;invalid mode: $&#123;mode&#125;&#96;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>从代码里面我们可以看到在<code>new</code>的时候确定了使用何种路由模式，并且根据传入options创建<code>matcher</code>。</p>
<p>接下来看看当使用<code>vue.use()</code>执行install方法做了什么：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">export function install (Vue) &#123;</span><br><span class="line">  if (install.installed &amp;&amp; _Vue &#x3D;&#x3D;&#x3D; Vue) return</span><br><span class="line">  install.installed &#x3D; true</span><br><span class="line"></span><br><span class="line">  _Vue &#x3D; Vue</span><br><span class="line"></span><br><span class="line">  const isDef &#x3D; v &#x3D;&gt; v !&#x3D;&#x3D; undefined</span><br><span class="line"></span><br><span class="line">  const registerInstance &#x3D; (vm, callVal) &#x3D;&gt; &#123;</span><br><span class="line">    let i &#x3D; vm.$options._parentVnode</span><br><span class="line">    if (isDef(i) &amp;&amp; isDef(i &#x3D; i.data) &amp;&amp; isDef(i &#x3D; i.registerRouteInstance)) &#123;</span><br><span class="line">      i(vm, callVal)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Vue.mixin(&#123;</span><br><span class="line">    beforeCreate () &#123;</span><br><span class="line">      if (isDef(this.$options.router)) &#123;</span><br><span class="line">        this._routerRoot &#x3D; this</span><br><span class="line">        this._router &#x3D; this.$options.router</span><br><span class="line">        this._router.init(this)</span><br><span class="line">        Vue.util.defineReactive(this, &#39;_route&#39;, this._router.history.current)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this._routerRoot &#x3D; (this.$parent &amp;&amp; this.$parent._routerRoot) || this</span><br><span class="line">      &#125;</span><br><span class="line">      registerInstance(this, this)</span><br><span class="line">    &#125;,</span><br><span class="line">    destroyed () &#123;</span><br><span class="line">      registerInstance(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(Vue.prototype, &#39;$router&#39;, &#123;</span><br><span class="line">    get () &#123; return this._routerRoot._router &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Object.defineProperty(Vue.prototype, &#39;$route&#39;, &#123;</span><br><span class="line">    get () &#123; return this._routerRoot._route &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  Vue.component(&#39;RouterView&#39;, View)</span><br><span class="line">  Vue.component(&#39;RouterLink&#39;, Link)</span><br><span class="line"></span><br><span class="line">  const strats &#x3D; Vue.config.optionMergeStrategies</span><br><span class="line">  &#x2F;&#x2F; use the same hook merging strategy for route hooks</span><br><span class="line">  strats.beforeRouteEnter &#x3D; strats.beforeRouteLeave &#x3D; strats.beforeRouteUpdate &#x3D; strats.created</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>install</code>方法里主要是<code>Vue.mixin</code>给每个组件混入了<code>beforeCreate</code>和 <code>destroyed </code>方法，在Vue的原型链上增加了<code>$router</code>和<code>$route</code>对象，这就是为什么我们使用Vue的时候在this上可以拿到这两个对象，注册了<code>router-view</code>和<code>router-link</code>两个组件。</p>
<h2 id="2-matcher和route"><a href="#2-matcher和route" class="headerlink" title="2. matcher和route"></a>2. matcher和route</h2><p>接下来看看<code>matcher</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export type Matcher &#x3D; &#123;</span><br><span class="line">  match: (raw: RawLocation, current?: Route, redirectedFrom?: Location) &#x3D;&gt; Route;</span><br><span class="line">  addRoutes: (routes: Array&lt;RouteConfig&gt;) &#x3D;&gt; void;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>matcher</code>暴露了<code>match</code>方法<code>addRoutes</code>方法，从方法的名字上看，match方法是用于路由匹配，addRoutes则是用来添加路由配置。</p>
<p>在执行<code>creatMatcher()</code>里第一代段代码生成了<code>pathList</code>、<code>pathMap</code>、<code>nameMap</code>这三个对象，这是后面路由执行匹配非常重要的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const &#123; pathList, pathMap, nameMap &#125; &#x3D; createRouteMap(routes)</span><br></pre></td></tr></table></figure>

<p><code>pathMap</code>和<code>nameMap</code>分别是以route配置的path和name为key生成的一个映射表，对应value为<code>RouteRecord</code>实例。</p>
<p>下面看看<code>RouteRecord</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">declare type RouteRecord &#x3D; &#123;</span><br><span class="line">  path: string;</span><br><span class="line">  regex: RouteRegExp;</span><br><span class="line">  components: Dictionary&lt;any&gt;;</span><br><span class="line">  instances: Dictionary&lt;any&gt;;</span><br><span class="line">  name: ?string;</span><br><span class="line">  parent: ?RouteRecord;</span><br><span class="line">  redirect: ?RedirectOption;</span><br><span class="line">  matchAs: ?string;</span><br><span class="line">  beforeEnter: ?NavigationGuard;</span><br><span class="line">  meta: any;</span><br><span class="line">  props: boolean | Object | Function | Dictionary&lt;boolean | Object | Function&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合代码里的实际数据对照理解各个属性的含义：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/6/7/16b318773604a842?w=1598&h=522&f=png&s=132269"></p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>path</td>
<td>传入的路径值</td>
</tr>
<tr>
<td>regex</td>
<td>根据path生成的正则匹配规则</td>
</tr>
<tr>
<td>components</td>
<td>path对应的组件</td>
</tr>
<tr>
<td>instances</td>
<td>执行路由守卫方法时传入的route实例</td>
</tr>
<tr>
<td>name</td>
<td>route的name</td>
</tr>
<tr>
<td>parent</td>
<td>route的父级，是一个递归的对象，从最底层一直到最顶层，无则为undefined</td>
</tr>
<tr>
<td>redirect</td>
<td>重定向的路径</td>
</tr>
<tr>
<td>matchAs</td>
<td>用于匹配alias</td>
</tr>
<tr>
<td>props</td>
<td>传入路由的参数</td>
</tr>
</tbody></table>
<p>结合以上解释，我们可以得出<code>vue-router</code>一个大概的运行概念。</p>
<ol>
<li><p>执行<code>new Router()</code>生成路由配置对象<code>routedRecord</code></p>
</li>
<li><p>路由匹配根据<code>route</code>对象的<code>regex</code>进行匹配</p>
</li>
<li><p>根据<code>route</code>的<code>parent</code>对象递归获取<code>component</code>组件生成<code>render Tree</code></p>
</li>
<li><p>执行各组件对应的导航守卫方法</p>
</li>
</ol>
<p>此文大概简述了vue-router是如何执行的，但是对于router跳转的具体执行并没有进行深入解释，下一篇文章将会详细说明router跳转之后是如何执行。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/07/%E5%AD%A6%E4%B9%A0vue-router%E6%BA%90%E7%A0%81%E8%AE%B0%E5%BD%95/" data-id="ckedpbruk000p1zm103ie4gsl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-HTTP协议从0-9-2-0的变化" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/01/HTTP%E5%8D%8F%E8%AE%AE%E4%BB%8E0-9-2-0%E7%9A%84%E5%8F%98%E5%8C%96/" class="article-date">
  <time datetime="2019-06-01T14:43:36.000Z" itemprop="datePublished">2019-06-01</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP/">HTTP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/06/01/HTTP%E5%8D%8F%E8%AE%AE%E4%BB%8E0-9-2-0%E7%9A%84%E5%8F%98%E5%8C%96/">HTTP协议从0.9-2.0的变化</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>HTTP是我们前端赖以存在的基础，HTTP协议一直在变化，我们又是否真的了解HTTP协议呢？下面一起学习HTTP协议的变化，了解HTTP协议不同版本改进的地方。</p>
</blockquote>
<h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h3><p>HTTP/0.9是最早的版本，确认了HTTP基于TCP协议。这个版本只支持GET一个方法，且服务器只能返回HTML格式的字符串。</p>
<h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h3><p>HTTP-1.0新增了许多内容，包括支持不同类型的响应格式，例如图像、视频等等。新增了HEAD和POST请求方法，补充了响应状态码，权限，缓存等功能。</p>
<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h3><p>HTTP/1.1引入了持久链接以及管道机制。</p>
<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP/2.0"></a>HTTP/2.0</h3><p>HTTP/2.0引入了二进制，多路复用，服务器推送（socket），数据流和头信息压缩优化。</p>
<h3 id="HTTP-3-0"><a href="#HTTP-3-0" class="headerlink" title="HTTP/3.0"></a>HTTP/3.0</h3><p>HTTP/3.0据说引入了新的协议（QUIC），该协议解决了以前TCP协议所存在的问题，并且极大的提升了性能与安全性。</p>
<h3 id="不同版本解决的问题"><a href="#不同版本解决的问题" class="headerlink" title="不同版本解决的问题"></a>不同版本解决的问题</h3><h4 id="0-9-–-gt-1-0"><a href="#0-9-–-gt-1-0" class="headerlink" title="0.9 –&gt; 1.0"></a>0.9 –&gt; 1.0</h4><p>从0.9到1.0版本，HTTP协议的变化极大丰富了前端页面可以交互的内容，在最早的时候可能我们所看到的只有一个纯文本的页面，但是到了1.0版本，新增了图像、音频等新的响应内容，前端可交互的内容变得更加丰富了。</p>
<h4 id="1-0-–-gt-1-1"><a href="#1-0-–-gt-1-1" class="headerlink" title="1.0 –&gt; 1.1"></a>1.0 –&gt; 1.1</h4><p>在1.0版本，因为每个TCP只能发送一个请求，发送数据之后连接就会关闭；每次发送新的请求就需要建立一个新的连接，而建立一个新的连接成本非常高昂，由此产生了<font color=red size=4>连接无法复用</font>的问题，存在性能问题。1.1版本引入的持久连接允许一个请求在数据返回之后保留一段时间，和管道机制允许我们同时发送多个请求。</p>
<h3 id="1-1-–-gt-2-0"><a href="#1-1-–-gt-2-0" class="headerlink" title="1.1 –&gt; 2.0"></a>1.1 –&gt; 2.0</h3><p>在1.1版本引入的管道机制允许我们同时发送多个请求，例如同时发送A和B请求，但是服务器还是会按照顺序先处理A请求，等A响应后再处理B请求，由此产生了我们所说的<font color=red size=4>线头阻塞（Head-of-line blocking）</font>问题。如果第一个响应处理非常久，则会导致后面的请求必须等待前面的请求处理完之后才能得到响应。</p>
<p>所以在2.0版本引入的多路复用和数据流允许我们不会受到前面处理非常耗时的请求影响，可以分优先级处理响应。同时引入了服务器推送（socket）增加了客户端与服务器双向通信的能力。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/01/HTTP%E5%8D%8F%E8%AE%AE%E4%BB%8E0-9-2-0%E7%9A%84%E5%8F%98%E5%8C%96/" data-id="ckedpbru700031zm18fc9hdnx" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-重新认识前端开发使用的『图片』" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/26/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%9A%84%E3%80%8E%E5%9B%BE%E7%89%87%E3%80%8F/" class="article-date">
  <time datetime="2019-05-26T14:43:49.000Z" itemprop="datePublished">2019-05-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/26/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%9A%84%E3%80%8E%E5%9B%BE%E7%89%87%E3%80%8F/">重新认识前端开发使用的『图片』</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>图片在前端开发中非常常用，但是图片的文件格式却是有很多种，平常我们使用的时候可能不会太在意这方面。实际上不同的图片格式有不同的应用的场景，从体验和性能优化的角度考虑也是值得我们学习。下面将简单介绍图片的常见类型。</p>
</blockquote>
<h2 id="图片类型介绍"><a href="#图片类型介绍" class="headerlink" title="图片类型介绍"></a>图片类型介绍</h2><h3 id="1-PNG"><a href="#1-PNG" class="headerlink" title="1.PNG"></a>1.PNG</h3><p>PNG格式有8位、24位、32位三种形式，其中8位PNG支持两种不同的透明形式（索引透明和alpha透明），24位PNG不支持透明，32位PNG在24位基础上增加了8位透明通道，因此可展现256级透明程度。</p>
<p>PNG图片支持无损压缩。</p>
<h3 id="2-JPG（JPEG）"><a href="#2-JPG（JPEG）" class="headerlink" title="2.JPG（JPEG）"></a>2.JPG（JPEG）</h3><p>JPG和JPEG其实是一个格式，而且可细分为Baseling-JPG和Progress-JPG两种。两种不同类型的图片各有适用场景，通常来说使用Progress—JPG给用户的体验更好。</p>
<p>JPG支持有损压缩。</p>
<ol>
<li>Baseling-JPG<br><img src="https://user-gold-cdn.xitu.io/2019/5/25/16aee808d26687af?w=310&h=248&f=gif&s=48572"></li>
<li>Progressive-JPG<br><img src="https://user-gold-cdn.xitu.io/2019/5/25/16aee80dcf7cd3b8?w=310&h=248&f=gif&s=104715"></li>
</ol>
<h3 id="3-GIF"><a href="#3-GIF" class="headerlink" title="3.GIF"></a>3.GIF</h3><p>GIF经常用于动画的图片上，支持无损压缩，支持背景透明。</p>
<h3 id="4-SVG"><a href="#4-SVG" class="headerlink" title="4.SVG"></a>4.SVG</h3><p>SVG（可缩放矢量图形）这种图片的类型我们可能用得比较少，实际上这种格式的图片优势非常多。</p>
<ol>
<li>基于可扩展标记语言</li>
<li>采用文本来描述对象</li>
<li>具有交互性和动态性</li>
<li>完全支持DOM</li>
</ol>
<p>SVG支持无损压缩和背景透明，而且还支持动画。</p>
<p>但是，SVG相比JPG和PNG来说优势这么大为何并没有很广泛的被应用呢？这和SVG的一部分优势相关，因为SVG太过灵活，实际开发中维护SVG图片成本非常高。</p>
<h3 id="5-WebP"><a href="#5-WebP" class="headerlink" title="5.WebP"></a>5.WebP</h3><p>WebP是谷歌开发出来的一种图片格式，所以并不是一个通常的标准格式（仅Chrome和Opera支持）。但是WebP因为其自家谷歌浏览器的份额高占有率，同时WebP相比其他常用的图片格式具有更大的优势，实际开发应用还是比较常见。</p>
<p>WebP同时支持无损和有损压缩，支持背景透明。</p>
<h3 id="6-APNG"><a href="#6-APNG" class="headerlink" title="6.APNG"></a>6.APNG</h3><p>APNG其实是在PNG的基础上扩展了支持动画的图片文件格式，这也不是一个通用的标准格式（仅Safari和Firefox支持）。</p>
<p>APNG支持无损压缩，背景透明，且额外支持动画。</p>
<h3 id="7-BPG"><a href="#7-BPG" class="headerlink" title="7.BPG"></a>7.BPG</h3><p>BPG是一种实验性的图片文件格式，在浏览器使用需要提供js解码，该图片格式并未成为通用标准。但是因为其相比其他图片格式，具有更高压缩比，且支持背景透明和动画，同时支持无损压缩和有损压缩，实际上有希望成为新的主流图片格式。</p>
<h2 id="有损压缩和无损压缩"><a href="#有损压缩和无损压缩" class="headerlink" title="有损压缩和无损压缩"></a>有损压缩和无损压缩</h2><p>前面介绍图片的时候提到的无损压缩和有损压缩是什么呢？实际上这个概念适用很多地方（视频，音频等），简单说说这两个的概念。</p>
<p>1.有损压缩</p>
<p>有损压缩是利用了人类对图像或声波中的某些频率成分不敏感的特性，允许压缩过程中损失一定的信息；虽然不能完全恢复原始数据，但是所损失的部分对理解原始图像的影响缩小，却换来了大得多的压缩比。</p>
<p>2.无损压缩</p>
<p>无损压缩格式，是利用数据的统计冗余进行压缩，可完全恢复原始数据而不引起任何失真。</p>
<blockquote>
<p>图片里有损压缩牺牲了部分图片细节，以此换来更大的压缩比。</p>
</blockquote>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><table>
<thead>
<tr>
<th>图片格式</th>
<th>支持透明</th>
<th>支持动画</th>
<th>压缩方式</th>
<th>浏览器支持</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td>PNG</td>
<td>支持</td>
<td>不支持</td>
<td>无损压缩</td>
<td>所有</td>
<td>需要透明时</td>
</tr>
<tr>
<td>JPG</td>
<td>不支持</td>
<td>不支持</td>
<td>有损压缩</td>
<td>所有</td>
<td>通用场景</td>
</tr>
<tr>
<td>GIF</td>
<td>支持</td>
<td>支持</td>
<td>无损压缩</td>
<td>所有</td>
<td>简单颜色、动画</td>
</tr>
<tr>
<td>SVG</td>
<td>支持</td>
<td>支持</td>
<td>无损压缩</td>
<td>所有</td>
<td>需要良好缩放体验，动态控制图片特效</td>
</tr>
<tr>
<td>WebP</td>
<td>支持</td>
<td>不支持</td>
<td>有损压缩和无损压缩</td>
<td>Chrome、Opera</td>
<td>复杂颜色、平台可知</td>
</tr>
<tr>
<td>APNG</td>
<td>支持</td>
<td>支持</td>
<td>无损压缩</td>
<td>Firefox、Safari</td>
<td>半透明动画</td>
</tr>
<tr>
<td>BPG</td>
<td>支持</td>
<td>支持</td>
<td>有损压缩和无损压缩</td>
<td>无，需要JS解码</td>
<td>极致性能优化</td>
</tr>
</tbody></table>
<p>在开发中虽然经常用到了图片，但是对不同的图片格式并没有太多认知，希望通过重新学习图片的知识，增强自己的业务能力。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/26/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BD%BF%E7%94%A8%E7%9A%84%E3%80%8E%E5%9B%BE%E7%89%87%E3%80%8F/" data-id="ckedpbrv8002e1zm1c9i0hw3z" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/Vue/">Vue</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Vue/" style="font-size: 20px;">Vue</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/15/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/">JS数据类型判断</a>
          </li>
        
          <li>
            <a href="/2019/08/10/CSS%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/">CSS容易忽略的一些知识点</a>
          </li>
        
          <li>
            <a href="/2019/07/15/%E5%AD%A6%E4%B9%A0vuex%E6%BA%90%E7%A0%81/">学习vuex源码</a>
          </li>
        
          <li>
            <a href="/2019/07/07/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94nextTick/">学习vue源码—nextTick</a>
          </li>
        
          <li>
            <a href="/2019/06/30/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94mvvm/">学习vue源码—mvvm</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Mr.Onion<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>