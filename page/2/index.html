<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Mr.Onion</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一个记录成长的前端博客">
<meta property="og:type" content="website">
<meta property="og:title" content="Mr.Onion">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Mr.Onion">
<meta property="og:description" content="一个记录成长的前端博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mr.Onion">
<meta property="article:tag" content="HTML、JavaScript、Css、Web、前端">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Mr.Onion" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.0.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mr.Onion</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-一篇文章带你理解HTTP缓存" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/18/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3HTTP%E7%BC%93%E5%AD%98/" class="article-date">
  <time datetime="2019-05-18T14:44:01.000Z" itemprop="datePublished">2019-05-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP/">HTTP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/18/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3HTTP%E7%BC%93%E5%AD%98/">一篇文章带你理解HTTP缓存</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么会有HTTP缓存？"><a href="#为什么会有HTTP缓存？" class="headerlink" title="为什么会有HTTP缓存？"></a>为什么会有HTTP缓存？</h2><p>HTTP缓存的存在是因为web前端的性能瓶颈大部分的原因在于HTTP传输的时间耗费过长。如果能够减少这种HTTP请求的时间，对网页的性能来说是非常大的提升，对于用户的体验也能得到极大的改善。</p>
<h2 id="HTTP缓存标识"><a href="#HTTP缓存标识" class="headerlink" title="HTTP缓存标识"></a>HTTP缓存标识</h2><p>HTTP缓存可分为<font color=blue>强缓存</font>（Cache-Control和Expires）以及<font color=blue>协商缓存</font>（Etag和Last-Modified）。</p>
<p>强缓存和协商缓存的区别在于：如果命中强缓存，会直接从缓存中读取资源，不向服务器请求。协商缓存则会向服务器请求确认资源是否过期。这也是缓存验证的顺序，先使用强缓存，后使用协商缓存。</p>
<p>下面则简单介绍一下这两种缓存类型的标识</p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control设置有效期max-age的值是时间的相对值。</p>
<p>下面则简单介绍Cache-Control常用的使用值：</p>
<table>
<thead>
<tr>
<th>value</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存。</td>
</tr>
<tr>
<td>private</td>
<td>表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）,可以缓存响应内容。</td>
</tr>
<tr>
<td>no-cache</td>
<td>在发布缓存副本之前，强制高速缓存将请求提交给原始服务器进行验证。</td>
</tr>
<tr>
<td>no-store</td>
<td>缓存不应存储有关客户端请求或服务器响应的任何内容。</td>
</tr>
<tr>
<td>max-age=&lt;seconds&gt;</td>
<td>设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与Expires相反，时间是相对于请求的时间。</td>
</tr>
<tr>
<td>must-revalidate</td>
<td>缓存必须在使用之前验证旧资源的状态，并且不可使用过期资源。</td>
</tr>
<tr>
<td>proxy-revalidate</td>
<td>与must-revalidate作用相同，但它仅适用于共享缓存（例如代理），并被私有缓存忽略。</td>
</tr>
</tbody></table>
<p>若想了解更详细的说明，可参考此链接：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control</a></p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires 响应头包含日期/时间， 即在此时候之后，响应过期。</p>
<p>Expires设置的值是一个绝对值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<h3 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h3><p>Etag HTTP响应头是资源的特定版本的标识符。这可以让缓存更高效，并节省带宽，因为如果内容没有改变，Web服务器不需要发送完整的响应。而如果内容发生了变化，使用ETag有助于防止资源的同时更新相互覆盖（“空中碰撞”）。</p>
<p>Etag的值是根据资源文件内容生成的一个hash值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Etag: 33a64df551425fcc55e4d42a148795d9f25f89d4</span><br></pre></td></tr></table></figure>

<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last-Modified"></a>Last-Modified</h3><p>Last-Modified包含源头服务器认定的资源做出修改的日期及时间。 它通常被用作一个验证器来判断接收到的或者存储的资源是否彼此一致。由于精确度比  ETag 要低，所以这是一个备用机制。</p>
<p>Last-Modified的值是一个时间的绝对值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></table></figure>

<h2 id="HTTP缓存验证规则"><a href="#HTTP缓存验证规则" class="headerlink" title="HTTP缓存验证规则"></a>HTTP缓存验证规则</h2><h3 id="HTTP缓存的验证顺序"><a href="#HTTP缓存的验证顺序" class="headerlink" title="HTTP缓存的验证顺序"></a>HTTP缓存的验证顺序</h3><ol>
<li>先使用强缓存（Cache-Control &gt; Expires） 判断资源是否过期；</li>
<li>若资源未过期则直接从缓存读取，若资源过期则使用协商缓存；</li>
<li>使用协商缓存（Etag &gt; Last-Modified）请求服务器确认资源有无修改（请求头会带上 If-None-Match 或 If-Modified-Since）；</li>
<li>若资源无修改则返回 <code>304</code> 状态码告诉客户端可读取缓存；若资源已修改则返回 <code>200</code> 状态码重新获取资源；</li>
</ol>
<p>图示：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/5/18/16ac9fe6feb72d69?w=1398&h=1298&f=png&s=344446"><br>图片来源：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/xiaohuochai/p/6178810.html">https://www.cnblogs.com/xiaohuochai/p/6178810.html</a></p>
<h3 id="HTTP缓存验证说明"><a href="#HTTP缓存验证说明" class="headerlink" title="HTTP缓存验证说明"></a>HTTP缓存验证说明</h3><p>以下的HTTP缓存验证说明是基于假设请求存在4个缓存头标记；</p>
<ol>
<li>HTTP缓存是否过期，先判断Cache-Control是否设置<code>max-age</code>或<code>s-max-age</code>，如果已设置则忽略Expires并且验证是否过期，否则验证Expires是否过期；其实按照MDN文档的说明，Last-Modified也是可以计算出一个缓存时间；</li>
</ol>
<p>下面是MDN文档的说明：</p>
<blockquote>
<p>对于含有特定头信息的请求，会去计算缓存寿命。比如Cache-control: max-age=N的头，相应的缓存的寿命就是N。通常情况下，对于不含这个属性的请求则会去查看是否包含Expires属性，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。如果max-age和expires属性都没有，找找头里的Last-Modified信息。如果有，缓存的寿命就等于头里面Date的值减去Last-Modified的值除以10（注：根据rfc2626其实也就是乘以10%）。</p>
</blockquote>
<p>缓存时间计算公式：</p>
<blockquote>
<p>expirationTime = responseTime + freshnessLifetime - currentAge</p>
</blockquote>
<ol start="2">
<li>如果该缓存未过期，是不会向服务器发送请求的，而是直接从缓存中读取，也就是我们可以从HTTP请求信息里得到的状态码 <code> 200 (from cache memory || from disk memory) </code>，如果缓存过期，则使用协商缓存；</li>
</ol>
<ul>
<li>先尝试从内存中读取，再尝试从硬盘中读取。</li>
<li>200 form memory cache 不访问服务器，一般已经加载过该资源且缓存在了内存当中，直接从内存中读取缓存。浏览器关闭后，数据将不存在（资源被释放掉了），再次打开相同的页面时，不会出现from memory cache。</li>
<li>200 from disk cache 不访问服务器，已经在之前的某个时间加载过该资源，直接从硬盘中读取缓存，关闭浏览器后，数据依然存在，此资源不会随着该页面的关闭而释放掉下次打开仍然会是from disk cache。</li>
</ul>
<ol start="3">
<li>使用协商缓存验证缓存资源是否修改；<font color=red>Etag &gt; Last-Modified</font>，当存在Etag则使用Etag，否则使用Last-Modified；并且请求时会带上特定的标识；</li>
</ol>
<ul>
<li>Etag 请求时会带上 If-None-Match</li>
<li>Last-Modified 请求时会带上 If-Modified-Since</li>
</ul>
<ol start="4">
<li>当确认资源未修改时则返回 <code> 304 (Not Modified)</code>告诉客户端可以继续使用缓存，否则返回<code>200</code>重新获取新的资源。</li>
</ol>
<p>HTTP缓存早期的时候只有Expires和Last-Modified，为什么后面又会出现Cache-Control和Etag呢？</p>
<p>先说说Expires和Cache-Control，Expires的值是一个准确的时间，比较的时候先根据返回头的Date值比较判断，但是若无Date头信息返回则是根据客户端的本地时间进行比较；本地时间因为各种因素影响，会存在各种不同的值，导致Expires缓存的时间并不是我们想要的效果。而Cache-Control设置max-age使用的相对值则相对来说控制粒度更精确了；并且Cache-Control的其他值则让我们对于缓存的控制更加灵活。</p>
<p>再说说Last-Modified和Etag，Last-Modified的值也是一个准确的时间，精确到秒；使用时间来判断资源是否修改则可能存在以下问题：</p>
<ol>
<li>1秒内的修改可能不被检查到，导致缓存无法更新；</li>
<li>资源可能只是多了几个空格或无变化，但是Last-Modified的时间已经变化；</li>
</ol>
<p>针对以上的问题所以有了Etag的存在，Etag是根据资源内容生成的hash值对比判断资源是否更新，控制粒度比Last-Modified更加精确。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>HTTP缓存的本质上是以空间换时间，缓存的存在是为了尽可能的减少HTTP请求次数和HTTP传输的内容大小，这也是前端性能优化中重要的一环。合理的设置页面资源的缓存，有助你提升页面的体验。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/18/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3HTTP%E7%BC%93%E5%AD%98/" data-id="ckedpbruc00071zm1h47b0gem" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-前端的安全问题与防御策略" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/05/12/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%B8%8E%E9%98%B2%E5%BE%A1%E7%AD%96%E7%95%A5/" class="article-date">
  <time datetime="2019-05-12T14:44:09.000Z" itemprop="datePublished">2019-05-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP/">HTTP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/05/12/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%B8%8E%E9%98%B2%E5%BE%A1%E7%AD%96%E7%95%A5/">前端的安全问题与防御策略</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>在前端的开发中，安全是我们必须要了解的一环，即使前端很难说有真正的安全，但是了解这些攻击有助于我们如何去规避问题，毕竟安全问题都是需要提前预防，而不能等到真正发生的时候才来解决。</p>
</blockquote>
<h2 id="ClickJacking（点击劫持）"><a href="#ClickJacking（点击劫持）" class="headerlink" title="ClickJacking（点击劫持）"></a>ClickJacking（点击劫持）</h2><p>1.什么是ClickJacking？</p>
<p><font color="blue">ClickJacking（点击劫持）</font>是一种视觉上的欺骗手段。大概有两种方式，一是攻击者使用一个透明的iframe，覆盖在一个网页上，然后诱使用户在该页面上进行操作，此时用户将在不知情的情况下点击透明的iframe页面；二是攻击者使用一张图片覆盖在网页，遮挡网页原有位置的含义。</p>
<p>2.如何防御ClickJacking</p>
<p>对于第一种情况我们可以通过设置http响应头标记X-Frame-Option来防止点击劫持。</p>
<p><font color="blue">X-Frame-Options</font>：X-Frame-Options HTTP 响应头是用来给浏览器指示允许一个页面可否在&lt;frame&gt;,&lt;iframe&gt;或者&lt;object&gt;中展现的标记。网站可以使用此功能，来确保自己网站的内容没有被嵌到别人的网站中去，也从而避免了点击劫持 (clickjacking) 的攻击。</p>
<table>
<thead>
<tr>
<th>标记值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DENY</td>
<td>表示该页面不允许在 frame 中展示，即便是在相同域名的页面中嵌套也不允许。</td>
</tr>
<tr>
<td>SAMEORIGIN</td>
<td>表示该页面可以在相同域名页面的 frame 中展示。</td>
</tr>
<tr>
<td>ALLOW-FROM uri</td>
<td>表示该页面可以在指定来源的 frame 中展示。</td>
</tr>
</tbody></table>
<p>除此之外我们还可以使用CSP（Content-Security-Policy）里的frame-ancestors或frame-src来指定页面允许嵌入哪些页面。</p>
<p>对于不使用X-Frame—Options或CSP，参考网上的解决方法，在打开页面的时候检查一下window.top和window.self是否相等来决定是否重定向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (window.self !&#x3D; window.top) &#123;</span><br><span class="line">    top.location.href &#x3D; self.location.href</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至于第二种情况使用图片遮挡网页原有位置的含义，这种站点本身就是一个恶意站点，而不是来自第三方的攻击，这里不做讨论。</p>
<h2 id="CSRF（跨站伪造请求）"><a href="#CSRF（跨站伪造请求）" class="headerlink" title="CSRF（跨站伪造请求）"></a>CSRF（跨站伪造请求）</h2><p>1.什么是CSRF？</p>
<p><font color="blue">CSRF（跨站伪造请求）</font>全称为 Cross-site request forgery，CSRF是通过伪装成受信任用户的请求来利用受信任的网站。例如：一位用户在站点A登录了，并且站点A把信息存储在用户本地，之后当用户打开站点B，站点B的恶意代码窃取了这位用户在站点A的个人用户信息，就可以假装成这位用户去请求站点A。</p>
<p>2.如何防御CSRF</p>
<ul>
<li>cookie不存储重要信息</li>
<li>cookie设置httpOnly，secure，此外path和domain尽量不使用默认值</li>
<li>cookie设置SameSite（这个属性还不是一个规范，不确定是否有用）</li>
<li>服务端增加多重安全校验</li>
<li>使用https协议或其他安全协议发送请求</li>
</ul>
<h2 id="XSS（跨站脚本攻击）"><a href="#XSS（跨站脚本攻击）" class="headerlink" title="XSS（跨站脚本攻击）"></a>XSS（跨站脚本攻击）</h2><p>1.什么是XSS？</p>
<p><font color="blue">XSS（跨站脚本攻击）</font>全称为Cross Site Scripting，为了和CSS文件（Cascading Style Sheets）区分，故称为XSS。XSS通过往Web页面插入恶意代码，当用户访问该页面时，执行嵌入的恶意代码，以此来达到恶意攻击用户的目的。</p>
<p>XSS攻击又分为存储型和反射型。</p>
<p>存储型：一般是指我们页面中表单提交的数据存在恶意代码被存储到数据库中。</p>
<p>反射型：需要欺骗用户自己去点击链接才能触发XSS代码</p>
<p>2.如何防御XSS</p>
<ul>
<li>CSP（Content-Security-Policy）</li>
</ul>
<p><font color="blue">CSP（Content-Security-Policy）</font>允许站点管理者在指定的页面控制用户代理的资源。</p>
<p>设置CSP可以极大程度上提高页面安全，CSP允许我们设置一套非常完善的资源允许请求规则，在此只大概罗列几个。</p>
<table>
<thead>
<tr>
<th>标记值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>script-src</td>
<td>限制javascript 源。</td>
</tr>
<tr>
<td>style-src</td>
<td>限制层叠样式表文件源。</td>
</tr>
<tr>
<td>img-src</td>
<td>限制图片和图标源。</td>
</tr>
<tr>
<td>media-src</td>
<td>限制通过&lt;audio&gt; 或&lt;video&gt; 标签加载的媒体文件源。</td>
</tr>
</tbody></table>
<ul>
<li>SRI（Subresource Integrity）</li>
</ul>
<p>在项目中我们可能会引入一些第三方的文件，因为文件在第三方的服务器里，理论上第三方是有可能篡改文件对使用第三方的文件的站点进行攻击。在这种情况下我们可以使用SRI来保证我们引入的文件不被篡改。</p>
<p><font color="blue">SRI（子资源完整性 Subresource Integrity ）</font>用于让浏览器检查所下载的来自第三方的资源（例如 CDN）未被恶意篡改。它使用哈希值检查确保第三方资源的完整性。只要开发者提供了被需下载资源的哈希值，浏览器就可以检查实际下载的文件是否与预期的哈希值匹配。</p>
<p>如何使用SRI？只需给 script 或 style 标签添加<font color="red" size="4">integrity</font>属性即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script crossorigin&#x3D;&quot;anonymous&quot; integrity&#x3D;&quot;shaxxx-xxxxxx&quot; src&#x3D;&quot;xxx.com&#x2F;xxx.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>要注意的是因为浏览器需要下载资源内容进行计算，所以如果引用第三方的文件需要第三方服务器支持<font>跨域请求（CORS）</font>，客户端则需要加上<font color="red" size="4">crossorigin=”anonymous”</font>属性。</p>
<p>另外，我们还可以使用CSP设置<font color="red" size="4">require-sri-for</font>强制页面请求js或css文件使用SRI。</p>
<ul>
<li>X-XSS-Protection</li>
</ul>
<p><font color="blue">X-XSS-Protection</font>响应头是浏览器检测到页面存在XSS攻击时，设置浏览器的行为。通常默认值为1，检测到XSS攻击浏览器将会删除不安全的部分。</p>
<table>
<thead>
<tr>
<th>标记值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>禁止XSS过滤。</td>
</tr>
<tr>
<td>1</td>
<td>启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。</td>
</tr>
<tr>
<td>1; mode=block</td>
<td>启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。</td>
</tr>
<tr>
<td>1; report=&lt;reporting-uri&gt;</td>
<td>启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。</td>
</tr>
</tbody></table>
<ul>
<li>对提交的数据encode或过滤</li>
</ul>
<p>在页面里提交的数据需要存储到数据库的场景下，我们需要对提交的数据进行encode或者某些特殊字符进行过滤，特别是某些数据我们需要用在src或href里使用的情况。</p>
<p>除此之外，富文本也是XSS经常发生的重灾区，对于富文本提交的数据是一定要进行过滤的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上文所述基本上是我们前端里常见的安全问题，其实对于前端来说很难有真正的安全所言，毕竟我们的代码都是明文跑在浏览器上。</p>
<p>而现在基本上不使用https协议的请求全部都是不安全的，对于页面上数据提交进行过滤校验也是常规操作，大部分场景我们都是使用浏览器的机制来帮助我们防御攻击，增加第三方攻击的成本。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/05/12/%E5%89%8D%E7%AB%AF%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E4%B8%8E%E9%98%B2%E5%BE%A1%E7%AD%96%E7%95%A5/" data-id="ckedpbrud00081zm126ha4dkv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习观察者模式与发布-订阅模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/27/%E5%AD%A6%E4%B9%A0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time datetime="2019-04-27T14:44:18.000Z" itemprop="datePublished">2019-04-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/27/%E5%AD%A6%E4%B9%A0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/">学习观察者模式与发布-订阅模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>最近学习了<font color="blue"><strong>观察者模式</strong></font>和<font color="blue"><strong>发布/订阅模式</strong></font>，但是一直有种不得要领的感觉，今天重新复习了一遍又有了新的思考，记录一下学习收获。</p>
</blockquote>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>概念引用原文的话如下：</p>
<blockquote>
<p>The Observer is a design pattern where an object (known as a subject) maintains a list of objects depending on it (observers), automatically notifying them of any changes to state.</p>
</blockquote>
<blockquote>
<p>一个对象（subject）维护一个对象列表（observers），当发生任何状态改变时自动通知它们</p>
</blockquote>
<p>根据概念画了一个大概的关系图</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/27/16a5de521a4a487a?w=472&h=601&f=png&s=24756"></p>
<p>接下来直接看看代码的实现</p>
<p>先是一个observeList类，这个类有几个维护observerList的方法，这几个方法是用来管理对象维护的观察者列表的方法（类似增删改查）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function ObserverList()&#123;</span><br><span class="line">    this.observerList &#x3D; [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObserverList.prototype.add &#x3D; function( obj )&#123;</span><br><span class="line">    return this.observerList.push( obj );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ObserverList.prototype.count &#x3D; function()&#123;</span><br><span class="line">    return this.observerList.length;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ObserverList.prototype.get &#x3D; function( index )&#123;</span><br><span class="line">    if( index &gt; -1 &amp;&amp; index &lt; this.observerList.length )&#123;</span><br><span class="line">        return this.observerList[ index ];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ObserverList.prototype.indexOf &#x3D; function( obj, startIndex )&#123;</span><br><span class="line">    var i &#x3D; startIndex;</span><br><span class="line"></span><br><span class="line">    while( i &lt; this.observerList.length )&#123;</span><br><span class="line">        if( this.observerList[i] &#x3D;&#x3D;&#x3D; obj )&#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return -1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ObserverList.prototype.removeAt &#x3D; function( index )&#123;</span><br><span class="line">    this.observerList.splice( index, 1 );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>接下来是subject类，用于给某个具体的被观察的对象继承，这个类有包装了新增观察者（addObserver）、移除观察者（removeObserver）以及通知观察者（notify）的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Subject()&#123;</span><br><span class="line">    this.observers &#x3D; new ObserverList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Subject.prototype.addObserver &#x3D; function( observer )&#123;</span><br><span class="line">    this.observers.add( observer );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Subject.prototype.removeObserver &#x3D; function( observer )&#123;</span><br><span class="line">    this.observers.removeAt( this.observers.indexOf( observer, 0 ) );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Subject.prototype.notify &#x3D; function( context )&#123;</span><br><span class="line">    var observerCount &#x3D; this.observers.count();</span><br><span class="line">    for(var i&#x3D;0; i &lt; observerCount; i++)&#123;</span><br><span class="line">        this.observers.get(i).update( context );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>最后是一个观察者的类，这个其实并不是强制要求以这个类来实现，只是说明了观察者需要暴露一个update方法，当subject的实例发生变化时，subject实例使用notify方法去调用观察者的update方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Observer()&#123;</span><br><span class="line">    this.update &#x3D; function()&#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚开始看观察者模式的时候一直不是很明白这个设计在开发中的应用，今天又重新看的时候忽然想起来和之前看vue的双向绑定一部分的实现很像。在双向绑定里当我们改变一个对象的值的时候，其他使用了这个值的地方也会对应改变，这和观察者模式的设计是比较类似的。</p>
<h2 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布/订阅模式"></a>发布/订阅模式</h2><p>发布/订阅模式和观察者模式有点类似，但是发布/订阅模式不存在观察者与被观察者的关系，这种设计模式相对于观察者模式更加的松耦合，实现代码如下：</p>
<p>一个对象如果提供了支持Publish()、Subscribe()和unsubscribe()的功能实现，就可以使用Publish/Subscribe。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">var pubsub &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">(function(myObject) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Storage for topics that can be broadcast</span><br><span class="line">    &#x2F;&#x2F; or listened to</span><br><span class="line">    var topics &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; A topic identifier</span><br><span class="line">    var subUid &#x3D; -1;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Publish or broadcast events of interest</span><br><span class="line">    &#x2F;&#x2F; with a specific topic name and arguments</span><br><span class="line">    &#x2F;&#x2F; such as the data to pass along</span><br><span class="line">    myObject.publish &#x3D; function( topic, args ) &#123;</span><br><span class="line"></span><br><span class="line">        if ( !topics[topic] ) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var subscribers &#x3D; topics[topic],</span><br><span class="line">            len &#x3D; subscribers ? subscribers.length : 0;</span><br><span class="line"></span><br><span class="line">        while (len--) &#123;</span><br><span class="line">            subscribers[len].func( topic, args );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return this;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Subscribe to events of interest</span><br><span class="line">    &#x2F;&#x2F; with a specific topic name and a</span><br><span class="line">    &#x2F;&#x2F; callback function, to be executed</span><br><span class="line">    &#x2F;&#x2F; when the topic&#x2F;event is observed</span><br><span class="line">    myObject.subscribe &#x3D; function( topic, func ) &#123;</span><br><span class="line"></span><br><span class="line">        if (!topics[topic]) &#123;</span><br><span class="line">            topics[topic] &#x3D; [];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var token &#x3D; ( ++subUid ).toString();</span><br><span class="line">        topics[topic].push(&#123;</span><br><span class="line">            token: token,</span><br><span class="line">            func: func</span><br><span class="line">        &#125;);</span><br><span class="line">        return token;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Unsubscribe from a specific</span><br><span class="line">    &#x2F;&#x2F; topic, based on a tokenized reference</span><br><span class="line">    &#x2F;&#x2F; to the subscription</span><br><span class="line">    myObject.unsubscribe &#x3D; function( token ) &#123;</span><br><span class="line">        for ( var m in topics ) &#123;</span><br><span class="line">            if ( topics[m] ) &#123;</span><br><span class="line">                for ( var i &#x3D; 0, j &#x3D; topics[m].length; i &lt; j; i++ ) &#123;</span><br><span class="line">                    if ( topics[m][i].token &#x3D;&#x3D;&#x3D; token ) &#123;</span><br><span class="line">                        topics[m].splice( i, 1 );</span><br><span class="line">                        return token;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return this;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;( pubsub ));</span><br></pre></td></tr></table></figure>

<p>发布/订阅模式和vue的eventBus异曲同工，在实际应用中，因为任何地方我们都可以订阅（subscribe）一个事件，也可以在任何地方发布（public）一个事件，所以在这个设计模式中，谁发布或者谁订阅了事件是无法感知的，这也是和观察者模式最大的区别。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>刚开始学习观察者模式和发布/订阅模式真的是完全没有什么感觉，简单的说的就是代码都看懂了，但是不知道有什么用。今天重新看了一遍，仔细想了一下设计的用法，和实际开发中对应起来就特别有感觉了，学习设计模式对于我们阅读源码和开发中体会框架的设计理念非常有帮助。</p>
<hr>
<p>参考文档：<a target="_blank" rel="noopener" href="https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript">https://addyosmani.com/resources/essentialjsdesignpatterns/book/#observerpatternjavascript</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/27/%E5%AD%A6%E4%B9%A0%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/" data-id="ckedpbrus00151zm16mo50aee" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-前端跨域的解决方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/20/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="article-date">
  <time datetime="2019-04-20T14:44:27.000Z" itemprop="datePublished">2019-04-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP/">HTTP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/20/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">前端跨域的解决方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>跨域可以说是前端开发中很常见的一个问题了，虽然网上已经有很多类似的文章，不过本着记录自己的学习总结想法，还是要自己写一遍文章记录一下所学知识。</p>
</blockquote>
<h2 id="为什么会有跨域？"><a href="#为什么会有跨域？" class="headerlink" title="为什么会有跨域？"></a>为什么会有跨域？</h2><p>跨域的问题产生是因为浏览器的<strong>同源策略</strong>所导致的。同源策略的出发点是出于浏览器的安全所考虑的，如果每个人都可以随意访问其他站点的文件数据，将会产生非常严重的安全问题。</p>
<p>那怎么样才算是跨域呢？在浏览器里只要满足以下条件任一个就算跨域：</p>
<blockquote>
<ol>
<li>请求协议不同 <br/>
例：http和https</li>
<li>域名不同<br/>
例：xxx.com和mmm.com</li>
<li>端口不同<br/>
例：xxx.com和xxx.com:81
</li>
</ol>
</blockquote>
<h2 id="跨域的几种解决方法"><a href="#跨域的几种解决方法" class="headerlink" title="跨域的几种解决方法"></a>跨域的几种解决方法</h2><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1. JSONP"></a>1. JSONP</h3><p>JSONP实现跨域的原理是动态创建script标签，src是具有跨域访问文件的能力，创建指定的地址和调用特定的回调方法获取数据，JSONP只支持get方法。</p>
<h3 id="2-CORS"><a href="#2-CORS" class="headerlink" title="2.CORS"></a>2.CORS</h3><p>CORS（跨域资源共享）实现跨域的原理是在http请求头中加上指定的标记来告诉浏览器是否允许加载跨域的资源，也是现在主流的跨越解决方案。</p>
<h3 id="3-iframe-location-hash"><a href="#3-iframe-location-hash" class="headerlink" title="3.iframe + location.hash"></a>3.iframe + location.hash</h3><p>iframe+location.hash实现跨域是使用iframe加载资源，然后在iframe中修改父窗口的location.hash，因为location.hash的信息会展示在url上，所以url的长度限制了我们传输信息内容的长度。</p>
<h3 id="4-iframe-window-name"><a href="#4-iframe-window-name" class="headerlink" title="4. iframe + window.name"></a>4. iframe + window.name</h3><p>iframe+location.hash实现跨域是使用iframe加载资源，然后在iframe窗口加载的内容修改window.name的值，使用了window.name的特性，在当前窗口页所有加载的页面共享一个window.name，但是window.name的容量限制为不超过2m。</p>
<h3 id="5-iframe-document-domain"><a href="#5-iframe-document-domain" class="headerlink" title="5. iframe + document.domain"></a>5. iframe + document.domain</h3><p>如果两个页面的主域名相同，但是子域名不同，可以修改document.domain为同一个域名，实现父子域名的跨域通信，只限制主域名相同的情况下。（不算严格意义上的跨域）</p>
<h3 id="6-postMessage"><a href="#6-postMessage" class="headerlink" title="6. postMessage"></a>6. postMessage</h3><p>postMessage是html5标准的新特性，使用该api可以实现多种场景的跨域通信，但是在一些比较老旧的浏览器可能不支持此方法。</p>
<h3 id="7-反向代理"><a href="#7-反向代理" class="headerlink" title="7.反向代理"></a>7.反向代理</h3><p>使用nginx或者nodejs中间件通过反向代理实现跨域访问。</p>
<h3 id="8-WebSocket协议"><a href="#8-WebSocket协议" class="headerlink" title="8.WebSocket协议"></a>8.WebSocket协议</h3><p>WebScoket协议支持跨域通信。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综合以上几种的跨域解决方案来看，解决跨域大都是在服务器端，不管是从安全性还是实用性上来说。使用前端手段解决跨域的方案或多或少都有点缺陷，前端解决跨域的重点也是在围绕src的能力来展开，不管是iframe还是动态创建script。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/20/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" data-id="ckedpbrue000c1zm15p436d2w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-深入学习正则表达式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/13/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="article-date">
  <time datetime="2019-04-13T14:44:34.000Z" itemprop="datePublished">2019-04-13</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/13/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">深入学习正则表达式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="正则里括号的用法"><a href="#正则里括号的用法" class="headerlink" title="正则里括号的用法"></a>正则里括号的用法</h2><h3 id="1-分组"><a href="#1-分组" class="headerlink" title="1. 分组"></a>1. 分组</h3><p>分组：正则表达式里括号的表达式为另外一组匹配规则</p>
<p>捕获括号：被匹配的子字符串可以在结果数组的元素 [1]-[n] 中找到，或在被定义的 RegExp 对象的属性 $1-$9 中找到。</p>
<p>代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;\d+(\D+)&#x2F;</span><br><span class="line">reg.exec(&#39;123456abcd&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;123456abcd&quot;, &quot;abcd&quot;, index: 0, input: &quot;123456abcd&quot;, groups: undefined]</span><br><span class="line">console.log(RegExp.$1)</span><br><span class="line">&#x2F;&#x2F; &quot;abcd&quot;</span><br></pre></td></tr></table></figure>

<p>在这个正则表达式里我们括号期望的是一组非数字的匹配项，并且执行匹配后可在执行结果的[1]或者RegExp.$1得到匹配值。</p>
<p>正则表达式括号的分组在实际开发中对于我们解决问题有非常大的用处，例如String.replace()这个方法</p>
<p>代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let str &#x3D; &#39;123abc&#39;</span><br><span class="line">let reg &#x3D; &#x2F;(\d+)(\D+)&#x2F;</span><br><span class="line">let newStr &#x3D; str.replace(reg, &#39;$2$1&#39;)</span><br><span class="line">console.log(newStr) &#x2F;&#x2F; abc123</span><br><span class="line">str.replace(reg, function(word, $1, $2)&#123;</span><br><span class="line">    console.log(word,$1,$2)</span><br><span class="line">    &#x2F;&#x2F; word代表字符串在正则匹配到的值, $1代表第一个括号的匹配项, $2代表第二个括号的匹配项</span><br><span class="line">    &#x2F;&#x2F; 123abc, 123, abc</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>使用正则表达式应用于字符串处理，在上面的例子里我们很容易得就把数字和字母的匹配项互换位置。</p>
<p>在另外一种情况下如果不想要捕获这个匹配项，但是又需要加括号匹配条件，我们可以使用非捕获括号</p>
<p>非捕获括号：匹配项不能够从结果数组的元素 [1]-[n] 或已被定义的 RegExp 对象的属性 $1-$9 再次访问到。</p>
<p>代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;\d+(?:\D+)&#x2F;</span><br><span class="line">reg.exec(&#39;123456abcd&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;123456abcd&quot;, index: 0, input: &quot;123456abcd&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>在例子里执行匹配后括号里的匹配项不会再出现结果里。</p>
<h3 id="2-反向引用"><a href="#2-反向引用" class="headerlink" title="2.反向引用"></a>2.反向引用</h3><p>反向引用：一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。</p>
<p>代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg &#x3D; &#x2F;(\d+)\D+\1&#x2F;</span><br><span class="line">reg.exec(&#39;123abc123&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;123abc123&quot;, &quot;123&quot;, index: 0, input: &quot;123abc123&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>在正则表达式里\1代表的是\d+，当我们在表达式里有需要重复的时候可以用这种写法。</p>
<h3 id="3-零宽断言"><a href="#3-零宽断言" class="headerlink" title="3.零宽断言"></a>3.零宽断言</h3><p>零宽断言：指一个用来描述或者匹配一系列符合某个句法规则的字符串的单个字符串。</p>
<ol>
<li>(?=pattern) 正向先行断言：代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern。</li>
<li>(?!pattern) 负向先行断言：代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配pattern。</li>
<li>(?&lt;=pattern) 正向后行断言：代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配pattern。</li>
<li>(?&lt;!pattern) 负向后行断言：代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配pattern。</li>
</ol>
<p>正则表达式的括号有时候用来表达断言，具体的细节我们在下面问内容详细说。</p>
<h2 id="贪婪模式与非贪婪模式"><a href="#贪婪模式与非贪婪模式" class="headerlink" title="贪婪模式与非贪婪模式"></a>贪婪模式与非贪婪模式</h2><p>贪婪模式与非贪婪模式也是正则里面比较常见的问题了，平时也会经常应用于开发中解决问题。理解贪婪模式和非贪婪模式对我们理解正则引擎执行匹配非常有帮助。</p>
<h3 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h3><p>贪婪模式会匹配尽可能多的字符，贪婪模式用于匹配优先量词修饰的子表达式，匹配优先量词包括：“{m，n}”、“{m，}”、“?”、“*”和“+”</p>
<p>代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;\d*&#x2F;</span><br><span class="line">reg.exec(&#39;1234567890&#39;)</span><br><span class="line">[&quot;1234567890&quot;, index: 0, input: &quot;1234567890&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>*号代表匹配任意次数，用大括号代表即{0,}，在贪婪模式下尽可能多的匹配，在例子中因为整个字符串完全匹配，所以匹配值为 1234567890。</p>
<h3 id="非贪婪模式"><a href="#非贪婪模式" class="headerlink" title="非贪婪模式"></a>非贪婪模式</h3><p>非贪婪模式会匹配尽可能少的字符，在匹配量词后面加上问号就可触发非贪婪模式：“{m，n}?”、“{m，}?”、“??”、“*?”和“+?”</p>
<p>代码举例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;\d*?&#x2F;</span><br><span class="line">reg.exec(&#39;1234567890&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;&quot;, index: 0, input: &quot;1234567890&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>*号代表匹配任意次数，用大括号代表即{0,}，因为*号可代表匹配0次，在非贪婪模式下尽可能少的匹配，所以在这个例子里匹配项为空，即不匹配任何字符串。</p>
<h2 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h2><p>正则表达式的断言功能非常强大，学习正则的断言应用，对于解决我们开发中的问题提供了新的思路。</p>
<p>在理解断言的执行过程可能会稍微有点绕，但是作为一个开发肯定要有一颗爱折腾的心，哈哈。</p>
<p>下面将只使用正向先行断言来说明断言的执行，其他的三个模式也是大同小异。</p>
<p>先看一个简单例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;abc(?&#x3D;123)&#x2F;</span><br><span class="line">reg.exec(&#39;abc123&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;abc&quot;, index: 0, input: &quot;abc123&quot;, groups: undefined]</span><br><span class="line"></span><br><span class="line">let reg2 &#x3D; &#x2F;abc(?&#x3D;1234)&#x2F;</span><br><span class="line">reg2.exec(&#39;abc123&#39;)</span><br><span class="line">&#x2F;&#x2F; null</span><br><span class="line"></span><br><span class="line">let reg3 &#x3D; &#x2F;abc(?&#x3D;12)&#x2F;</span><br><span class="line">reg3.exec(&#39;abc123&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;abc&quot;, index: 0, input: &quot;abc123&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>先按照正则的字面意思理解，/abc(?=123)/期望的匹配为即匹配abc，<strong>且abc后面的字符串能够满足括号的匹配规则</strong>，注意的是括号里面可以为其他<strong>正则表达式</strong>，并不是说abc后面只能包含123，而是后面可以满足括号的匹配则为断言成功。</p>
<p>在reg2的匹配过程中，因为abc后面的字符串不满足括号的匹配规则，所以断言失败，执行匹配也失败了。</p>
<p>在这几个例子里还没有体现出我们概念里说的意思，重温一下正向先行断言的概念</p>
<p>(?=pattern) 正向先行断言：代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern</p>
<p>概念里说的意思断言是在字符串中寻找符合断言的一个位置</p>
<p>举例说明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;(?&#x3D;abc).*&#x2F;</span><br><span class="line">reg.exec(&#39;123abc123&#39;)</span><br><span class="line">&#x2F;&#x2F; [&quot;abc123&quot;, index: 3, input: &quot;123abc123&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>

<p>先分析正则表达式，在满足abc匹配条件的位置后面匹配任意字符。在这个例子里，存在abc满足断言的匹配规则，但是为什么匹配到的是abc123？</p>
<p>在这里就回到我们的标题，零宽断言，零宽的意思就是执行断言是不会消耗我们正则表达式在匹配过程中的字符串，并且，断言是在帮我们确定符合断言匹配规则的位置。所以，(?=abc)会帮我们确定一个断言成功的位置，即3和a之间的位置，然后在这个断言成功的位置开始执行匹配（.*）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let reg &#x3D; &#x2F;(?&#x3D;abc)\d+&#x2F;</span><br><span class="line">reg.exec(&#39;123abc123&#39;)</span><br><span class="line">&#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，虽然abc的断言成功，但是断言只是帮我们确定一个位置，然后再执行\d+匹配规则，因为断言是不会消耗字符串，所以实际上以abc123去和\d+匹配，最后匹配结果为null。</p>
<p>基于此我们可以使用断言帮我们从一开始检索整个字符串是否满足某些规则，有助于提升匹配效率。</p>
<p>如下例子，我们可以使用断言从一开始判断整个字符串是否全部由数字组成，如果断言失败，则不执行匹配，这对于我们应用于表单校验非常有助于提升效率。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reg &#x3D; &#x2F;(?&#x3D;^\d+$)\d+&#x2F;</span><br><span class="line">reg.exec(&#39;123456&#39;)  &#x2F;&#x2F; 123456</span><br><span class="line">reg.exec(&#39;123456a&#39;) &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<p>另外没有介绍到的三种模式也是大同小异，在这里也就不重复赘述。但是两种后行断言可能会存在兼容性问题，后行断言应该是ES2018新增的规范。</p>
<p>零宽断言的重点是要理解“<strong>零宽</strong>”以及“<strong>位置</strong>”这两个点。</p>
<p>最后总结一下：正则表达式是一门非常实用的工具语言，基本上只要学习了就能够对于我们实际开发中产生帮助，平时某些开发工具中也可以使用正则表达式去检索某些文档，对于提升效率真的是帮助非常大。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/13/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" data-id="ckedpbruv00191zm15zpfd6xw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-理解JS的eventloop" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/06/%E7%90%86%E8%A7%A3JS%E7%9A%84eventloop/" class="article-date">
  <time datetime="2019-04-06T14:47:26.000Z" itemprop="datePublished">2019-04-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/06/%E7%90%86%E8%A7%A3JS%E7%9A%84eventloop/">理解JS的eventloop</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>异步，已经是js里变成必不可少的，而说到异步我们就不得不来说说js的event loop机制。</p>
<p>首先，一定要记住的一点：<strong>js是单线程的。</strong></p>
<p>在event loop机制里，还涉及到宏任务（task）和微任务（Microtasks）概念，具体概念本文不作解释，说下属于这两个类型的分类：</p>
<ol>
<li>宏任务：script、setTimeout、setInterval</li>
<li>微任务：Promise.then()、process.nextTick()</li>
</ol>
<p>event loop在执行的时候先执行当前宏任务中的同步代码，碰到属于异步的代码，则先判断是属于宏任务还是微任务，然后注册新的任务到任务队列中。当前同步代码执行完成后将执行当前宏任务的微任务队列，直到微任务队列为空时我们将执行一个新的宏任务队列。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/4/6/169f0f290787f313?w=800&h=658&f=jpeg&s=42740"></p>
<p>接下来就让我们用代码来理解event loop到底是怎么回事。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(3)</span><br></pre></td></tr></table></figure>

<p>看到这段代码我们很容易知道答案</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1 3 2</span><br></pre></td></tr></table></figure>

<p>在这段代码里，setTimeout设置了一个定时任务（宏任务），将延迟多少时间后执行。</p>
<p>接下来再把promise加进来看看</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(3)</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(6)</span><br></pre></td></tr></table></figure>

<p>这里打印的结果是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1 3 4 6 5 2</span><br></pre></td></tr></table></figure>

<p>接下来我们对结果进行分析</p>
<p>首先执行同步的代码，new Promise()中的代码属于同步任务，所以先打印出1 3 4 6；当前代码有2个异步代码，setTimeout和Promise.then()，前面我们已经说过，setTimeout属于宏任务，Promise.then属于微任务，所以当前宏任务队列执行完后将执行当前队列的微任务。</p>
<p>所以最后部分打印结果 5 2</p>
<p>接下来再看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(3)</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(5)</span><br><span class="line">    &#125;)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(6)</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(7)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(8)</span><br></pre></td></tr></table></figure>

<p>打印结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1 3 4 8 6 2 5 7</span><br></pre></td></tr></table></figure>

<p>分析的结果和上一部分代码是一样的，setTimeout属于宏任务将在当前宏任务执行完成后执行，执行顺序和注册任务的先后顺序有关。</p>
<p>最后再两个例子说明script和setTimeout属于宏任务类型</p>
<p>第一个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    console.log(1)</span><br><span class="line"></span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(2)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    console.log(3)</span><br><span class="line"></span><br><span class="line">    new Promise(function (resolve, reject) &#123;</span><br><span class="line">        console.log(4)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(function () &#123;</span><br><span class="line">        console.log(5)</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            console.log(7)</span><br><span class="line">        &#125;)</span><br><span class="line">        new Promise(function (resolve, reject) &#123;</span><br><span class="line">            console.log(8)</span><br><span class="line">            resolve()</span><br><span class="line">        &#125;).then(function () &#123;</span><br><span class="line">            console.log(9)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    if (true) console.log(6)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;index2.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>第二个例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">    let node &#x3D; document.createElement(&#39;script&#39;)</span><br><span class="line">    node.src &#x3D; &#39;.&#x2F;index2.js&#39;</span><br><span class="line">    document.body.append(node)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(3)</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(7)</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function (resolve, reject) &#123;</span><br><span class="line">        console.log(8)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(function () &#123;</span><br><span class="line">        console.log(9)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">if(true) console.log(6)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;index2.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>index2.js的代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(2)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(3)</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">    console.log(4)</span><br><span class="line">    resolve()</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    console.log(5)</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(7)</span><br><span class="line">    &#125;)</span><br><span class="line">    new Promise(function (resolve, reject) &#123;</span><br><span class="line">        console.log(8)</span><br><span class="line">        resolve()</span><br><span class="line">    &#125;).then(function () &#123;</span><br><span class="line">        console.log(9)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">if(true) console.log(6)</span><br></pre></td></tr></table></figure>

<p>在这两个例子中setTimeout的执行顺序和我们script创建时的顺序有关，根据event loop的执行机制分析即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/06/%E7%90%86%E8%A7%A3JS%E7%9A%84eventloop/" data-id="ckedpbruw001b1zm135ug1p1x" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习valueOf和toString，理解隐式转化规则" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/29/%E5%AD%A6%E4%B9%A0valueOf%E5%92%8CtoString%EF%BC%8C%E7%90%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96%E8%A7%84%E5%88%99/" class="article-date">
  <time datetime="2019-03-29T14:45:11.000Z" itemprop="datePublished">2019-03-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/HTTP/">HTTP</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/29/%E5%AD%A6%E4%B9%A0valueOf%E5%92%8CtoString%EF%BC%8C%E7%90%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96%E8%A7%84%E5%88%99/">学习valueOf和toString，理解隐式转化规则</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>js在比较运算过程中经常会发生隐式转换，常常会给人意料外的结果，而隐式转换在面试过程中又经常会被考到，所以打算好好整理一下隐式转换这个知识点，本文算是个人对隐式转换的学习梳理。</p>
<h2 id="1-toString和valueOf"><a href="#1-toString和valueOf" class="headerlink" title="1.toString和valueOf"></a>1.toString和valueOf</h2><p>toString：toString()函数的作用是返回object的字符串表示</p>
<ul>
<li>Array 返回数组元素的字符串，默认以逗号链接。</li>
<li>Boolean 布尔值的字符串值</li>
<li>Date 日期UTC标准格式</li>
<li>Function 函数的字符串值</li>
<li>Number 数字值的字符串值</li>
<li>Object [Object Object]</li>
<li>String 字符串值</li>
<li>Reg 正则的字符串值</li>
</ul>
<p>如下代码演示（以下演示情况是toString方法没有被重写）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let num &#x3D; 1</span><br><span class="line">let str &#x3D; &#39;a&#39;</span><br><span class="line">let bool &#x3D; true</span><br><span class="line">let obj &#x3D; &#123;&#125;</span><br><span class="line">let date &#x3D; new Date()</span><br><span class="line">let reg &#x3D; &#x2F;\d&#x2F;</span><br><span class="line">let arr &#x3D; [1, 2, 3]</span><br><span class="line">let fun &#x3D; function () &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(num.toString())   &#x2F;&#x2F; &#39;1&#39;</span><br><span class="line">console.log(str.toString())   &#x2F;&#x2F; &#39;a&#39;</span><br><span class="line">console.log(bool.toString())  &#x2F;&#x2F; &#39;true&#39;</span><br><span class="line">console.log(obj.toString())   &#x2F;&#x2F; &#39;[object Object]&#39;</span><br><span class="line">console.log(date.toString())  &#x2F;&#x2F; &#39;Thu Mar 28 2019 17:07:40 GMT+0800 (中国标准时间)&#39;</span><br><span class="line">console.log(reg.toString())   &#x2F;&#x2F; &#39;&#x2F;\d&#x2F;&#39;</span><br><span class="line">console.log(arr.toString())   &#x2F;&#x2F; &#39;1,2,3&#39;</span><br><span class="line">console.log(fun.toString())   &#x2F;&#x2F; &#39;function()&#123;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>valueOf：valueOf()函数将对象转换为原始值</p>
<ul>
<li>Array 返回数组对象本身</li>
<li>Boolean 布尔值</li>
<li>Date 返回时间是从 1970 年 1 月 1 日午夜开始计的毫秒数 UTC</li>
<li>Function 函数本身</li>
<li>Number 数字值</li>
<li>Object 对象本身，这是默认情况。</li>
<li>String 字符串值</li>
<li>Reg 正则本身</li>
</ul>
<p>如下代码演示（以下演示情况是valueOf方法没有被重写）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">console.log(num.valueOf())   &#x2F;&#x2F; 1</span><br><span class="line">console.log(str.valueOf())   &#x2F;&#x2F; &#39;a&#39; </span><br><span class="line">console.log(bool.valueOf())  &#x2F;&#x2F; true</span><br><span class="line">console.log(obj.valueOf())   &#x2F;&#x2F; &#123;&#125;</span><br><span class="line">console.log(date.valueOf())  &#x2F;&#x2F; 1553766610534</span><br><span class="line">console.log(reg.valueOf())   &#x2F;&#x2F; &#x2F;\d&#x2F;</span><br><span class="line">console.log(arr.valueOf())   &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">console.log(fun.valueOf())   &#x2F;&#x2F; fun()</span><br></pre></td></tr></table></figure>

<p>以上铺垫了这么多，是因为在隐式转换过程中经常会有用到调用对象的toString和valueOf方法</p>
<h2 id="2-隐式转换规则"><a href="#2-隐式转换规则" class="headerlink" title="2. 隐式转换规则"></a>2. 隐式转换规则</h2><p>以下为隐式转换时的规则：</p>
<ol>
<li>转化成字符串：使用字符串连接符 +</li>
<li>转化成数字：<br>2.1 ++/– （自加/自减） 2.2 + - * / % （算术运算）2.3 &gt; &lt; &gt;= &lt;= == != === !== （关系运算符）</li>
<li>转成布尔值：使用！非运算符</li>
</ol>
<h3 id="2-1-字符串连接符和算法运算符混淆"><a href="#2-1-字符串连接符和算法运算符混淆" class="headerlink" title="2.1 字符串连接符和算法运算符混淆"></a>2.1 字符串连接符和算法运算符混淆</h3><p>先看看以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; 1</span><br><span class="line">console.log(a + &#39;1&#39;)          &#x2F;&#x2F; &#39;11&#39;</span><br><span class="line">console.log(a + null)         &#x2F;&#x2F; 1</span><br><span class="line">console.log(a + undefined)    &#x2F;&#x2F; NaN (Number(undefined) &#x3D; NaN)</span><br><span class="line">console.log(a + true)         &#x2F;&#x2F; 2</span><br><span class="line">console.log(a + &#123;&#125;)           &#x2F;&#x2F; &#39;1[object Object]&#39;</span><br><span class="line">console.log(a + [1, 2, 3])    &#x2F;&#x2F; &#39;11,2,3&#39;</span><br><span class="line">console.log(a + new Date())   &#x2F;&#x2F; &#39;1Fri Mar 29 2019 10:12:41 GMT+0800 (中国标准时间)&#39;</span><br><span class="line">console.log(a + &#x2F;\d&#x2F;)         &#x2F;&#x2F; &#39;1&#x2F;\d&#x2F;&#39;</span><br><span class="line">console.log(a + function()&#123;&#125;) &#x2F;&#x2F; &#39;1function()&#123;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>从打印的结果可以知道</p>
<ol>
<li>当 + 号为字符串连接符时，则调用对象的toString方法转化为字符串然后相加</li>
<li>当 + 号为算术运算符时，则调用Number()方法转化然后相加</li>
</ol>
<p>在这里我们需要注意的是null、布尔值和undefined这三类对象使用 + 进行操作，当有一边确定为数字的时候，这三类值会尝试用Number()进行转化，<strong>如果有一边类型确定为字符串的时候，直接就是进行字符串相加</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#39;1&#39;</span><br><span class="line">console.log(a + null)         &#x2F;&#x2F; &#39;1null&#39;</span><br><span class="line">console.log(a + undefined)    &#x2F;&#x2F; &#39;1undefined&#39;</span><br><span class="line">console.log(a + true)         &#x2F;&#x2F; &#39;1true&#39;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-关系运算符会把其他数据类型转换成number之后再比较关系"><a href="#2-2-关系运算符会把其他数据类型转换成number之后再比较关系" class="headerlink" title="2.2 关系运算符会把其他数据类型转换成number之后再比较关系"></a>2.2 关系运算符会把其他数据类型转换成number之后再比较关系</h3><p>先看看以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;2&#39; &gt; 10)    &#x2F;&#x2F; false</span><br><span class="line">console.log(&#39;2&#39; &gt; &#39;10&#39;)  &#x2F;&#x2F; true</span><br><span class="line">console.log(&#39;a&#39; &gt; &#39;b&#39;)   &#x2F;&#x2F; false</span><br><span class="line">console.log(&#39;ab&#39; &gt; &#39;aa&#39;) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>从打印的结果可以知道</p>
<ol>
<li>当关系比较有一边为数字的时候，会把其他数据类型调用Number()转化为数字后进行运算</li>
<li>当关系比较两边都为字符串的时候，会同时把字符串转化为数字进行比较，但是不是用Number()进行转化，而是按照字符串的unicode编码进行转化(string.charCodeAt,默认为字符的第一位)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;a&#39; &gt; &#39;b&#39;)   &#x2F;&#x2F; false</span><br><span class="line">&#x2F;&#x2F; &#39;a&#39;.charCodeAt() &gt; &#39;b&#39;.charCodeAt()</span><br><span class="line">console.log(&#39;ab&#39; &gt; &#39;aa&#39;) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 第一位都是a相等，所以比较第二位的 b.charCodeAt() &gt; a.charCodeAt()</span><br></pre></td></tr></table></figure>

<h3 id="2-3-复杂数据类型在隐式转换时会先转成String，然后再转成Number运算"><a href="#2-3-复杂数据类型在隐式转换时会先转成String，然后再转成Number运算" class="headerlink" title="2.3 复杂数据类型在隐式转换时会先转成String，然后再转成Number运算"></a>2.3 复杂数据类型在隐式转换时会先转成String，然后再转成Number运算</h3><p>复杂类型数据指的是对象或数组这类数据进行隐式转换时，会先调用valueOf后调用toString方法转化成数据，再调用Number()转化成数字进行运算。</p>
<p>如果这个对象的valueOf方法和toString方法被重写过，则会根据valueOf返回的数据类型判断是否执行toString。</p>
<p>接下来代码示范：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">    valueOf: function () &#123;</span><br><span class="line">        console.log(&#39;执行valueOf&#39;)</span><br><span class="line">        return &#39;a&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: function () &#123;</span><br><span class="line">        console.log(&#39;执行toString&#39;)</span><br><span class="line">        return &#39;a&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a &#x3D;&#x3D; &#39;a&#39;)</span><br><span class="line">&#x2F;&#x2F; 执行valueOf</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>接下来尝试把valueOf返回值改成数字：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">    valueOf: function () &#123;</span><br><span class="line">        console.log(&#39;执行valueOf&#39;)</span><br><span class="line">        return 1</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: function () &#123;</span><br><span class="line">        console.log(&#39;执行toString&#39;)</span><br><span class="line">        return &#39;a&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a &#x3D;&#x3D; &#39;a&#39;)</span><br><span class="line">&#x2F;&#x2F; 执行valueOf</span><br><span class="line">&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>尝试把valueOf返回值改成对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">    valueOf: function () &#123;</span><br><span class="line">        console.log(&#39;执行valueOf&#39;)</span><br><span class="line">        return &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString: function () &#123;</span><br><span class="line">        console.log(&#39;执行toString&#39;)</span><br><span class="line">        return &#39;a&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(a &#x3D;&#x3D; &#39;a&#39;)</span><br><span class="line">&#x2F;&#x2F; 执行valueOf</span><br><span class="line">&#x2F;&#x2F; 执行toString</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>通过上面的例子我们可以得出结论：</p>
<ol>
<li>valueOf返回的数据类型决定是否调用toString，如果返回的类型是数字或者字符串(其实用基础数据类型更准确点)，toString方法就不执行了。</li>
<li>转化成字符串后再调用Number()转化成数字进行比较</li>
</ol>
<p>这里还有个问题就是如果toString方法返回不是基础类型，进行比较的时候则会报错。</p>
<h3 id="2-4-逻辑非隐式转换与关系运算符隐式转换混淆"><a href="#2-4-逻辑非隐式转换与关系运算符隐式转换混淆" class="headerlink" title="2.4 逻辑非隐式转换与关系运算符隐式转换混淆"></a>2.4 逻辑非隐式转换与关系运算符隐式转换混淆</h3><p>当使用!逻辑非运算符进行转化的时候，会尝试把数据转化成布尔值</p>
<p>以下情况使用Boolean()转化将会得到false</p>
<p>0、-0、undefined、null、NaN、false、’’(空字符串)、document.all</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">console.log([] &#x3D;&#x3D; 0)    &#x2F;&#x2F; true</span><br><span class="line">console.log(![] &#x3D;&#x3D; 0)   &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; [] &#x3D;&#x3D; 0 --&gt; [].valueOf().toString()得到空字符串，Number(&#39;&#39;) &#x3D;&#x3D; 0 成立</span><br><span class="line">&#x2F;&#x2F; ![] &#x3D;&#x3D; 0 --&gt; Boolean([])得到true再取反，最后转化成数字0，Number(!true) &#x3D;&#x3D; 0 成立</span><br><span class="line"></span><br><span class="line">console.log([] &#x3D;&#x3D; ![])  &#x2F;&#x2F; true</span><br><span class="line">console.log([] &#x3D;&#x3D; [])   &#x2F;&#x2F; false</span><br><span class="line">&#x2F;&#x2F; [] &#x3D;&#x3D; ![] --&gt; [].valueOf().toString()得到空字符串，Number(&#39;&#39;)取得0，Boolean([])得到true再取反，转化成数字0，最后Number(&#39;&#39;) &#x3D;&#x3D; Number(!true) 成立</span><br><span class="line">&#x2F;&#x2F; [] &#x3D;&#x3D; [] --&gt; 两个数组比较是因为两个数据的引用指向不一致，所以 [] &#x3D;&#x3D; [] 不成立</span><br><span class="line"></span><br><span class="line">console.log(&#123;&#125; &#x3D;&#x3D; !&#123;&#125;)  &#x2F;&#x2F; false</span><br><span class="line">console.log(&#123;&#125; &#x3D;&#x3D; &#123;&#125;)   &#x2F;&#x2F; false</span><br><span class="line">&#x2F;&#x2F; &#123;&#125; &#x3D;&#x3D; !&#123;&#125; --&gt; &#123;&#125;.valueOf().toString()得到&#39;[object Object]&#39;，Boolean(&#123;&#125;)得到true再取反，所以 &#39;[object Object]&#39; &#x3D;&#x3D; false 不成立</span><br><span class="line">&#x2F;&#x2F; &#123;&#125; &#x3D;&#x3D; &#123;&#125; --&gt; 两个对象比较是因为两个数据的引用指向不一致，所以 &#123;&#125; &#x3D;&#x3D; &#123;&#125; 不成立</span><br></pre></td></tr></table></figure>

<p>最后总结一下，在复杂数据类型隐式转化过程中会调用valueOf和toString方法，所以如果这两个方法被改写了往往会得到一些意料外的结果。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/29/%E5%AD%A6%E4%B9%A0valueOf%E5%92%8CtoString%EF%BC%8C%E7%90%86%E8%A7%A3%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96%E8%A7%84%E5%88%99/" data-id="ckedpbruh000i1zm13wiy29go" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-理解__proto__和prototype" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/22/%E7%90%86%E8%A7%A3__proto__%E5%92%8Cprototype/" class="article-date">
  <time datetime="2019-03-22T03:32:31.000Z" itemprop="datePublished">2019-03-22</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/22/%E7%90%86%E8%A7%A3__proto__%E5%92%8Cprototype/">理解__proto__和prototype</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>__proto__和prototype是我们理解javascript最容易混淆的两个东西，但是理解了这两个对我们学习对象的继承和原型链有非常大的帮助。</p>
<p>下面先说说这两个东西的概念：</p>
<p>__proto__ ：指向一个对象的原型</p>
<p>prototype ：函数特有的一个对象属性，并不是一个空对象，该对象里有一个constructor属性，指向当前的构造函数</p>
<p>当我们使用new来执行一个函数时，实例会继承prototype对象上的属性，同时函数里的this将会指向调用这个构造函数的实例对象</p>
<p>下面将使用代码说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let father &#x3D; function () &#123;</span><br><span class="line">    this.a &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">father.prototype.b &#x3D; 2</span><br><span class="line"></span><br><span class="line">let fatherIns &#x3D; new father()</span><br><span class="line"></span><br><span class="line">console.log(fatherIns) &#x2F;&#x2F; &#123;a: 1&#125;</span><br><span class="line">console.log(fatherIns.b) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>声明一个fatherIns的变量使用new关键词调用father，此时father函数里的this将会指向fatherIns，当我们打印这个对象时，fatherIns上并没有b这个属性，但是当我们尝试打印fatherIns.b时，之前我们在father.prototype上增加了一个<code>b = 2</code>的值，这时候js会尝试在这个对象原型链上寻找这个值，直到原型链最后为null，如果不存在这个属性则将会报出undefined的错误。</p>
<p>为什么fatherIns.b会在原型链上被找到，这个时候就轮到__proto__出场</p>
<p>__proto__是告诉js某个对象的原型对象指向谁，js就知道在原型链上下一步往哪去找</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(fatherIns.__proto__) &#x2F;&#x2F; &#123;b: 2&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以得出以下结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatherIns.__proto__ &#x3D;&#x3D;&#x3D; father.prototype</span><br></pre></td></tr></table></figure>

<p>由此可知原型链就是这么来的，经典结论如下：</p>
<p>JS里一切皆对象，对象的原型为null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fatherIns.__proto__.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype</span><br><span class="line"></span><br><span class="line">fatherIns.__proto__.__proto__.__proto__ &#x3D;&#x3D;&#x3D; null</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/22/%E7%90%86%E8%A7%A3__proto__%E5%92%8Cprototype/" data-id="ckedpbruy001e1zm10dj89hcv" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习node Assert + mocha + should断言测试，travis-CI持续集成项目" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/16/%E5%AD%A6%E4%B9%A0node%20Assert%20+%20mocha%20+%20should%E6%96%AD%E8%A8%80%E6%B5%8B%E8%AF%95%EF%BC%8Ctravis-CI%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%A1%B9%E7%9B%AE/" class="article-date">
  <time datetime="2019-03-16T09:22:51.000Z" itemprop="datePublished">2019-03-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Node-js/">Node.js</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/16/%E5%AD%A6%E4%B9%A0node%20Assert%20+%20mocha%20+%20should%E6%96%AD%E8%A8%80%E6%B5%8B%E8%AF%95%EF%BC%8Ctravis-CI%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%A1%B9%E7%9B%AE/">学习node Assert + mocha + should断言测试，travis-CI持续集成项目</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="node-Assert-api学习"><a href="#node-Assert-api学习" class="headerlink" title="node Assert api学习"></a>node Assert api学习</h2><ol>
<li>assert.strictEqual() / assert.notStrictEqual() 判断期望值与实际值是否相等或不相等</li>
<li>assert.deepStrictEqual() / assert.notDeepStrictEqual() 判断对象是否完全相等或不相等（深度遍历对象的可枚举属性，且递归对比子对象的可枚举属性）</li>
<li>assert.throws() / assert.doesNotThrow() 判断执行的函数是否抛出错误</li>
<li>assert.rejects() / assert.doesNotReject() 判断执行异步函数是否返回拒绝状态的Promise</li>
<li>assert.ok() 判断是否为真值</li>
<li>assert.ifError() 判断实际值是否为undefined 或 null</li>
<li>assert.fail() 默认抛出AssertionError提供的错误提示，如果是Error实例，则抛出实例错误提示</li>
</ol>
<p>以上为个人对Assert类的api理解，第三方断言库的语法基本和此接近，用法上可能更方便，语义化更好。</p>
<h2 id="mocha-should"><a href="#mocha-should" class="headerlink" title="mocha + should"></a>mocha + should</h2><p><a target="_blank" rel="noopener" href="https://mochajs.org/">mocha</a>单元测试框架</p>
<p><a target="_blank" rel="noopener" href="http://shouldjs.github.io/">should</a>BDD风格第三方断言库，mocha同时也支持其他第三方断言库，选择哪看个人喜好</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/15/16981e8c40ebddc7?w=1920&h=656&f=png&s=134977"></p>
<p>根据mocha的Github文档说明安装mocha，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g mocha</span><br></pre></td></tr></table></figure>

<p>增加一个名为mocha.opts的配置文件，文件内容为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--require should</span><br></pre></td></tr></table></figure>

<p>可直接默认添加依赖，无需手动required</p>
<p><em>提示：使用最新版本的mocha在package.json文件所在目录下执行mocha命令不会加载opts文件，降低版本可解决这个问题</em></p>
<p>以下代码为should文档使用的例子</p>
<p>引入should依赖后自动绑定should的api到Object.prototype原型上，如果是Object.create(null)创建的则使用should(params)来使用should的api，具体api参考should文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var should &#x3D; require(&#39;should&#39;);</span><br><span class="line"></span><br><span class="line">var user &#x3D; &#123;</span><br><span class="line">    name: &#39;tj&#39;</span><br><span class="line">  , pets: [&#39;tobi&#39;, &#39;loki&#39;, &#39;jane&#39;, &#39;bandit&#39;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user.should.have.property(&#39;name&#39;, &#39;tj&#39;);</span><br><span class="line">user.should.have.property(&#39;pets&#39;).with.lengthOf(4);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; If the object was created with Object.create(null)</span><br><span class="line">&#x2F;&#x2F; then it doesn&#39;t inherit &#96;Object.prototype&#96;, so it will not have &#96;.should&#96; getter</span><br><span class="line">&#x2F;&#x2F; so you can do:</span><br><span class="line">should(user).have.property(&#39;name&#39;, &#39;tj&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; also you can test in that way for null&#39;s</span><br><span class="line">should(null).not.be.ok();</span><br><span class="line"></span><br><span class="line">someAsyncTask(foo, function(err, result)&#123;</span><br><span class="line">  should.not.exist(err);</span><br><span class="line">  should.exist(result);</span><br><span class="line">  result.bar.should.equal(foo);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>下面代码为一个测试用例，测试一个大数相加的函数，输入与输出是否一致:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let add &#x3D; require(&#39;..&#x2F;lib&#x2F;add&#39;)</span><br><span class="line"></span><br><span class="line">describe(&#39;大数相加add方法&#39;, function () &#123;</span><br><span class="line">    it(&#39;字符串&quot;42329&quot;加上字符串&quot;21532&quot;等于&quot;63861&quot;&#39;, function () &#123;</span><br><span class="line">        add(&#39;42329&#39;, &#39;21532&#39;)</span><br><span class="line">            .should.equal(&#39;63861&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    it(&#39;&quot;843529812342341234&quot;加上&quot;236124361425345435&quot;等于&quot;1079654173767686669&quot;&#39;, function () &#123;</span><br><span class="line">        add(&#39;843529812342341234&#39;, &#39;236124361425345435&#39;)</span><br><span class="line">            .should.equal(&#39;1079654173767686669&#39;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>describe()定义了一组测试用例，describe()内可重复嵌套describe()，第一个参数为测试用例命名，第二个参数为执行的函数</p>
<p>在项目目录下运行mocha命令执行测试<br><img src="https://user-gold-cdn.xitu.io/2019/3/15/16981fc41dbbb857?w=1278&h=340&f=png&s=34723"><br>大数相加的函数输出值与我们输入的期望值则通过测试。</p>
<h2 id="Karma-mocha-travis-CI"><a href="#Karma-mocha-travis-CI" class="headerlink" title="Karma + mocha + travis-CI"></a>Karma + mocha + travis-CI</h2><p><a target="_blank" rel="noopener" href="https://karma-runner.github.io/1.0/index.html">Krama</a> 一个基于Node.js的JavaScript测试执行过程管理工具</p>
<p><a target="_blank" rel="noopener" href="https://www.travis-ci.org/">travis-CI</a> 持续集成构建项目</p>
<p>首先根据krama Github文档安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g krama</span><br></pre></td></tr></table></figure>

<p>安装完成后在我们的项目中执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">karma init</span><br></pre></td></tr></table></figure>

<p>执行命令后按照官网文档说明初始化部分配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">$ karma init</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 选择使用的测试框架</span><br><span class="line">Which testing framework do you want to use?</span><br><span class="line">Press tab to list possible options. Enter to move to the next question.</span><br><span class="line">&gt; jasmine</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 是否使用require.js</span><br><span class="line">Do you want to use Require.js?</span><br><span class="line">This will add Require.js plugin.</span><br><span class="line">Press tab to list possible options. Enter to move to the next question.</span><br><span class="line">&gt; no</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 是否自动绑定浏览器</span><br><span class="line">Do you want to capture a browser automatically?</span><br><span class="line">Press tab to list possible options. Enter empty string to move to the next question.</span><br><span class="line">&gt; Chrome</span><br><span class="line">&gt; Firefox</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输入你的项目依赖源和测试的文件，一个一个输入，最后生成一个数组</span><br><span class="line">What is the location of your source and test files?</span><br><span class="line">You can use glob patterns, eg. &quot;js&#x2F;*.js&quot; or &quot;test&#x2F;**&#x2F;*Spec.js&quot;.</span><br><span class="line">Press Enter to move to the next question.</span><br><span class="line">&gt; *.js</span><br><span class="line">&gt; test&#x2F;**&#x2F;*.js</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 排除部分文件</span><br><span class="line">Should any of the files included by the previous patterns be excluded?</span><br><span class="line">You can use glob patterns, eg. &quot;**&#x2F;*.swp&quot;.</span><br><span class="line">Press Enter to move to the next question.</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听文件并且当文件改变时候执行测试</span><br><span class="line">Do you want Karma to watch all the files and run the tests on change?</span><br><span class="line">Press tab to list possible options.</span><br><span class="line">&gt; yes</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后本人项目生成的karma配置文件如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Karma configuration</span><br><span class="line">&#x2F;&#x2F; Generated on Tue Mar 12 2019 21:15:08 GMT+0800 (China Standard Time)</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; function (config) &#123;</span><br><span class="line">    config.set(&#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; base path that will be used to resolve all patterns (eg. files, exclude)</span><br><span class="line">        basePath: &#39;&#39;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; frameworks to use</span><br><span class="line">        &#x2F;&#x2F; available frameworks: https:&#x2F;&#x2F;npmjs.org&#x2F;browse&#x2F;keyword&#x2F;karma-adapter</span><br><span class="line">        frameworks: [&#39;mocha&#39;],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; list of files &#x2F; patterns to load in the browser</span><br><span class="line">        files: [</span><br><span class="line">            &#39;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;jquery&#x2F;2.2.4&#x2F;jquery.js&#39;,</span><br><span class="line">            &#39;node_modules&#x2F;should&#x2F;should.js&#39;,</span><br><span class="line">            &#39;test&#x2F;**.js&#39;</span><br><span class="line">        ],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; list of files to exclude</span><br><span class="line">        exclude: [],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; preprocess matching files before serving them to the browser</span><br><span class="line">        &#x2F;&#x2F; available preprocessors: https:&#x2F;&#x2F;npmjs.org&#x2F;browse&#x2F;keyword&#x2F;karma-preprocessor</span><br><span class="line">        preprocessors: &#123;&#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; test results reporter to use</span><br><span class="line">        &#x2F;&#x2F; possible values: &#39;dots&#39;, &#39;progress&#39;</span><br><span class="line">        &#x2F;&#x2F; available reporters: https:&#x2F;&#x2F;npmjs.org&#x2F;browse&#x2F;keyword&#x2F;karma-reporter</span><br><span class="line">        reporters: [&#39;progress&#39;],</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; web server port</span><br><span class="line">        port: 9876,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; enable &#x2F; disable colors in the output (reporters and logs)</span><br><span class="line">        colors: true,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; level of logging</span><br><span class="line">        &#x2F;&#x2F; possible values: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG</span><br><span class="line">        logLevel: config.LOG_INFO,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; enable &#x2F; disable watching file and executing tests whenever any file changes</span><br><span class="line">        autoWatch: true,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; start these browsers</span><br><span class="line">        &#x2F;&#x2F; available browser launchers: https:&#x2F;&#x2F;npmjs.org&#x2F;browse&#x2F;keyword&#x2F;karma-launcher</span><br><span class="line">        browsers: [&#39;Chrome&#39;],</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Continuous Integration mode</span><br><span class="line">        &#x2F;&#x2F; if true, Karma captures browsers, runs the tests and exits</span><br><span class="line">        singleRun: true,</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Concurrency level</span><br><span class="line">        &#x2F;&#x2F; how many browser should be started simultaneous</span><br><span class="line">        concurrency: Infinity</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>把我们的项目接入travis-CI持续集成，首先登陆travis-CI网站<a target="_blank" rel="noopener" href="https://www.travis-ci.org/">https://www.travis-ci.org/</a></p>
<p><em>提示：需要有自己的github账号，并且以github账号授权登陆travis-ci网站</em></p>
<p>登陆后可以看到自己github上所有项目仓库，选择你需要持续集成的项目仓库</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/16/1698468b9abfcecc?w=1382&h=654&f=png&s=95231"><br>按照文档说明要在项目目录下新增一个.travis.yml文件，配置文件内容参考文档<a target="_blank" rel="noopener" href="https://docs.travis-ci.com/user/languages/javascript-with-nodejs/">https://docs.travis-ci.com/user/languages/javascript-with-nodejs/</a></p>
<p>下面是简单的配置文件说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">language: node_js</span><br><span class="line">node_js:</span><br><span class="line">  - &quot;lts&#x2F;*&quot;</span><br><span class="line">before_script:</span><br><span class="line">  - export DISPLAY&#x3D;:99.0</span><br><span class="line">  - sh -e &#x2F;etc&#x2F;init.d&#x2F;xvfb start</span><br></pre></td></tr></table></figure>

<p>language: 定义我们测试的语言</p>
<p>node_js: 定义node的版本，可以指定某个特定的版本<br><img src="https://user-gold-cdn.xitu.io/2019/3/16/169845b68d5ea417?w=560&h=302&f=png&s=23934"><br>按照文档说明，travis-CI执行测试默认执行npm install安装依赖包，安装完依赖后默认执行npm test命令执行测试任务。</p>
<p>before_script:在script配置命令前执行</p>
<p>根据karma官网文档说明接入travis-CI的配置里说明<a target="_blank" rel="noopener" href="http://karma-runner.github.io/1.0/plus/travis.html">http://karma-runner.github.io/1.0/plus/travis.html</a></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/16/169846092e4584de?w=2042&h=636&f=png&s=108274"></p>
<p>新增.travis.yml文件后并上传到github项目仓库中，在travis-ci网站中打开开关，travis-ci检测到配置文件会自动执行测试命令</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/16/169846e9815e2c76?w=3336&h=766&f=png&s=180559"></p>
<p>在job log标签页中可以看到执行任务的日志</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/16/169847192a1e0f81?w=2728&h=1766&f=png&s=430910"></p>
<p>根据任务日志可以看到我们的测试任务执行情况，4个测试用例均通过测试。</p>
<p>在集成travis-ci到项目中遇到了不少坑，翻了文档看了很多配置，一开始以为是chrome-launch的问题，在before_script中手动安装也是报错；另外一开始是看到文档里是对firefox配置，以为这是专门针对firefox的配置，后来照着karma接入travis-ci的文档配置尝试一下，居然成功了，这结果来得太意外。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/16/1698476b924555b9?w=2042&h=636&f=png&s=108274"></p>
<p>另外在karma.conf的文件中，singleRun的配置也需要配置成true，不然travis-ci任务会一直执行。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/3/16/169847b76a941a40?w=497&h=73&f=png&s=9990"></p>
<p>以上所述为第一次探索自动化测试的过程，确实学习到了很多东西，但是很多高级的用法并不太了解，也有不足的地方没有接入到真实项目中配合使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/16/%E5%AD%A6%E4%B9%A0node%20Assert%20+%20mocha%20+%20should%E6%96%AD%E8%A8%80%E6%B5%8B%E8%AF%95%EF%BC%8Ctravis-CI%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%A1%B9%E7%9B%AE/" data-id="ckedpbruf000d1zm11v6qc1su" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CSS/">CSS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/HTTP/">HTTP</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/Vue/">Vue</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Node-js/">Node.js</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSS/" rel="tag">CSS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTTP/" rel="tag">HTTP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Node-js/" rel="tag">Node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/" rel="tag">Vue</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/CSS/" style="font-size: 10px;">CSS</a> <a href="/tags/HTTP/" style="font-size: 15px;">HTTP</a> <a href="/tags/JavaScript/" style="font-size: 20px;">JavaScript</a> <a href="/tags/Node-js/" style="font-size: 10px;">Node.js</a> <a href="/tags/Vue/" style="font-size: 20px;">Vue</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">八月 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">八月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">六月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">五月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">三月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/15/JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/">JS数据类型判断</a>
          </li>
        
          <li>
            <a href="/2019/08/10/CSS%E5%AE%B9%E6%98%93%E5%BF%BD%E7%95%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86%E7%82%B9/">CSS容易忽略的一些知识点</a>
          </li>
        
          <li>
            <a href="/2019/07/15/%E5%AD%A6%E4%B9%A0vuex%E6%BA%90%E7%A0%81/">学习vuex源码</a>
          </li>
        
          <li>
            <a href="/2019/07/07/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94nextTick/">学习vue源码—nextTick</a>
          </li>
        
          <li>
            <a href="/2019/06/30/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E7%A0%81%E2%80%94mvvm/">学习vue源码—mvvm</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Mr.Onion<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>